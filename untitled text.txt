Vai ai contenuti
Cronologia chat



Hai detto:
ipv-pro-vendor-server-v1.4.0-optimized-autoinstaller.zip
Archivio zip
[14-Dec-2025 14:23:12 UTC] PHP Fatal error:  Uncaught Error: Class "IPV_Vendor_API_Gateway" not found in /home/customer/www/aiedintorni.it/public_html/wp-content/plugins/ipv-pro-vendor-optimized/includes/class-vendor-core.php:51
Stack trace:
#0 /home/customer/www/aiedintorni.it/public_html/wp-content/plugins/ipv-pro-vendor-optimized/includes/class-vendor-core.php(27): IPV_Vendor_Core->init_hooks()
#1 /home/customer/www/aiedintorni.it/public_html/wp-content/plugins/ipv-pro-vendor-optimized/includes/class-vendor-core.php(20): IPV_Vendor_Core->__construct()
#2 /home/customer/www/aiedintorni.it/public_html/wp-content/plugins/ipv-pro-vendor-optimized/ipv-pro-vendor.php(86): IPV_Vendor_Core::instance()
#3 /home/customer/www/aiedintorni.it/public_html/wp-includes/class-wp-hook.php(341): {closure}('')
#4 /home/customer/www/aiedintorni.it/public_html/wp-includes/class-wp-hook.php(365): WP_Hook->apply_filters(NULL, Array)
#5 /home/customer/www/aiedintorni.it/public_html/wp-includes/plugin.php(522): WP_Hook->do_action(Array)
#6 /home/customer/www/aiedintorni.it/public_html/wp-settings.php(593): do_action('plugins_loaded')
#7 /home/customer/www/aiedintorni.it/public_html/wp-config.php(172): require_once('/home/customer/...')
#8 /home/customer/www/aiedintorni.it/public_html/wp-load.php(50): require_once('/home/customer/...')
#9 /home/customer/www/aiedintorni.it/public_html/wp-admin/admin.php(35): require_once('/home/customer/...')
#10 /home/customer/www/aiedintorni.it/public_html/wp-admin/plugins.php(10): require_once('/home/customer/...')
#11 {main}
  thrown in /home/customer/www/aiedintorni.it/public_html/wp-content/plugins/ipv-pro-vendor-optimized/includes/class-vendor-core.php on line 51
ChatGPT ha detto:

Ragionato per 2m 42s
L‚Äôerrore √® chiarissimo: nel file includes/class-api-gateway.php la classe si chiama IPV_Vendor_API_Gateway_Optimized, mentre il core (class-vendor-core.php riga 51) prova a istanziare IPV_Vendor_API_Gateway ‚áí quindi PHP non la trova e va in fatal.

Ho preparato una versione FIXED del plugin che aggiunge uno shim di compatibilit√†: crea la classe IPV_Vendor_API_Gateway e la fa puntare alla classe ottimizzata, includendo anche il metodo statico legacy per il cron (clear_old_cache).

‚úÖ Scarica qui lo ZIP corretto:
Download ipv-pro-vendor-server-v1.4.0-optimized-autoinstaller-FIXED.zip

Come applicarlo (senza sorprese)
Disattiva il plugin attuale (se non riesci da admin, rinomina via FTP la cartella ipv-pro-vendor-optimized in ipv-pro-vendor-optimized_old).

Carica e installa lo ZIP FIXED da Plugin ‚Üí Aggiungi nuovo ‚Üí Carica plugin.

Riattiva il plugin.

Se vuoi, incollami anche le prime ~120 righe di ipv-pro-vendor-optimized/ipv-pro-vendor.php (file principale) e ti dico se conviene aggiungere un controllo ‚Äúclass_exists‚Äù preventivo per evitare fatal futuri quando rinomini classi._

Hai detto:
[14-Dec-2025 14:56:11 UTC] IPV Vendor: Plugin attivato con successo v1.4.0-optimized
[14-Dec-2025 14:56:12 UTC] PHP Deprecated:  strpos(): Passing null to parameter #1 ($haystack) of type string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 7374
[14-Dec-2025 14:56:12 UTC] PHP Deprecated:  str_replace(): Passing null to parameter #3 ($subject) of type array|string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 2196
[14-Dec-2025 14:56:12 UTC] PHP Deprecated:  strpos(): Passing null to parameter #1 ($haystack) of type string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 7374
[14-Dec-2025 14:56:12 UTC] PHP Deprecated:  str_replace(): Passing null to parameter #3 ($subject) of type array|string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 2196
[14-Dec-2025 14:56:13 UTC] PHP Deprecated:  strpos(): Passing null to parameter #1 ($haystack) of type string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 7374
[14-Dec-2025 14:56:13 UTC] PHP Deprecated:  str_replace(): Passing null to parameter #3 ($subject) of type array|string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 2196
[14-Dec-2025 14:56:13 UTC] PHP Deprecated:  strpos(): Passing null to parameter #1 ($haystack) of type string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 7374
[14-Dec-2025 14:56:13 UTC] PHP Deprecated:  str_replace(): Passing null to parameter #3 ($subject) of type array|string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 2196
[14-Dec-2025 14:56:13 UTC] PHP Deprecated:  strip_tags(): Passing null to parameter #1 ($string) of type string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-admin/admin-header.php on line 41
[14-Dec-2025 14:56:33 UTC] PHP Deprecated:  strpos(): Passing null to parameter #1 ($haystack) of type string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 7374
[14-Dec-2025 14:56:33 UTC] PHP Deprecated:  str_replace(): Passing null to parameter #3 ($subject) of type array|string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 2196
[14-Dec-2025 14:56:33 UTC] PHP Deprecated:  strpos(): Passing null to parameter #1 ($haystack) of type string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 7374
[14-Dec-2025 14:56:33 UTC] PHP Deprecated:  str_replace(): Passing null to parameter #3 ($subject) of type array|string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 2196
[14-Dec-2025 14:56:33 UTC] PHP Deprecated:  strip_tags(): Passing null to parameter #1 ($string) of type string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-admin/admin-header.php on line 41
[14-Dec-2025 14:57:38 UTC] PHP Deprecated:  strpos(): Passing null to parameter #1 ($haystack) of type string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 7374
[14-Dec-2025 14:57:38 UTC] PHP Deprecated:  str_replace(): Passing null to parameter #3 ($subject) of type array|string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 2196
[14-Dec-2025 14:57:38 UTC] PHP Deprecated:  strpos(): Passing null to parameter #1 ($haystack) of type string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 7374
[14-Dec-2025 14:57:38 UTC] PHP Deprecated:  str_replace(): Passing null to parameter #3 ($subject) of type array|string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 2196
[14-Dec-2025 14:57:38 UTC] PHP Deprecated:  strip_tags(): Passing null to parameter #1 ($string) of type string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-admin/admin-header.php on line 41
[14-Dec-2025 14:57:59 UTC] PHP Deprecated:  strpos(): Passing null to parameter #1 ($haystack) of type string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 7374
[14-Dec-2025 14:57:59 UTC] PHP Deprecated:  str_replace(): Passing null to parameter #3 ($subject) of type array|string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 2196
[14-Dec-2025 14:57:59 UTC] PHP Deprecated:  strpos(): Passing null to parameter #1 ($haystack) of type string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 7374
[14-Dec-2025 14:57:59 UTC] PHP Deprecated:  str_replace(): Passing null to parameter #3 ($subject) of type array|string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-includes/functions.php on line 2196
[14-Dec-2025 14:57:59 UTC] PHP Deprecated:  strip_tags(): Passing null to parameter #1 ($string) of type string is deprecated in /home/customer/www/aiedintorni.it/public_html/wp-admin/admin-header.php on line 41
ChatGPT ha detto:

Ragionato per 2m 29s
Perfetto: il fatal √® risolto (plugin attivato).
Quello che vedi adesso sono solo warning ‚ÄúPHP Deprecated‚Äù (non bloccano il sito), tipici di PHP 8.1/8.2/8.3 quando WordPress (o un plugin/tema) passa null a funzioni che ora pretendono stringhe.

Nel tuo log per√≤ i warning puntano a file core di WordPress:

wp-includes/functions.php (strpos / str_replace con null)

wp-admin/admin-header.php (strip_tags con null)

Quindi hai 2 strade pratiche:

A) Soluzione veloce (consigliata in produzione): nascondi i Deprecated
Nel wp-config.php metti/aggiusta cos√¨:

define('WP_DEBUG', true);
define('WP_DEBUG_LOG', true);
define('WP_DEBUG_DISPLAY', false);
@ini_set('display_errors', '0');
Questo non li elimina, ma evita che ‚Äúsporchino‚Äù output/admin e li lascia nel log.

Se vuoi proprio non loggarli, allora (solo se ti va bene) puoi ridurre l‚Äôerror_reporting lato PHP (php.ini o .user.ini):

error_reporting = E_ALL & ~E_DEPRECATED & ~E_USER_DEPRECATED
B) Soluzione ‚Äúpulita‚Äù: aggiorna WordPress + tema + plugin
Questi deprecated spesso spariscono aggiornando WordPress e componenti (specie se WP non √® all‚Äôultimissima e PHP √® gi√† 8.2/8.3).

Per capire CHI li genera davvero (e fixarlo sul serio)
Siccome nel log non c‚Äô√® stack trace, il modo pi√π rapido √®:

Lascia WP_DEBUG_LOG attivo e WP_DEBUG_DISPLAY a false

Aggiungi temporaneamente in wp-config.php:

define('SCRIPT_DEBUG', true);
Poi dimmi versione WordPress e versione PHP (le vedi in ‚ÄúBacheca ‚Üí Aggiornamenti‚Äù e ‚ÄúStrumenti ‚Üí Salute del sito‚Äù), oppure incollami l‚Äôoutput di ‚ÄúSalute del sito ‚Üí Info‚Äù.

Con quelle 2 info ti dico se √® quasi certamente WP core non allineato alla tua PHP, o se c‚Äô√® un plugin/tema che sta impostando un titolo/admin screen a null (quello che scatena strip_tags(null) in admin-header.php)._

Hai detto:
https://wordpress.org/plugins/subscriptions-for-woocommerce/

mi dici se √® questo il plugin per i pagamenti mensili?
ChatGPT ha detto:
S√¨ üëç ‚Äî ‚ÄúSubscriptions for WooCommerce‚Äù (quello che hai linkato) √® un plugin che ti permette di trasformare prodotti WooCommerce in abbonamenti con pagamenti ricorrenti (mensili, settimanali, annuali, ecc.) e gestire il modello di pagamenti ricorrenti dal pannello WooCommerce. 
WordPress.org
+1

üîé In breve
‚ùó √à un‚Äôalternativa ai plugin a pagamento come WooCommerce Subscriptions (l‚Äôestensione ufficiale di WooCommerce) ma orientata a essere pi√π semplice e pi√π ‚Äúleggera‚Äù. 
WordPress.org
+1

üì¶ Con questo plugin puoi:

Creare abbonamenti per prodotti fisici, digitali o servizi. 
WordPress.org

Forzare pagamenti ricorrenti (es. mensili) e gestire rinnovi. 
WordPress.org

Offrire prove gratuite, fee di iscrizione, cancellazioni automatiche, ecc. 
WordPress.org

Permettere agli utenti di gestire i propri abbonamenti dal proprio account. 
WordPress.org

‚ö†Ô∏è Attenzione alle limitazioni
üß© Questo plugin pu√≤ avere meno compatibilit√† con tutte le gateway di pagamento rispetto all‚Äôestensione ufficiale WooCommerce Subscriptions (che √® pi√π robusta e supportata nativamente da WooCommerce). 
WooCommerce

üí≥ Alcuni gateway potrebbero non supportare pagamenti ricorrenti automatici se non integrati correttamente. Devi verificare che il tuo metodo di pagamento supporti pagamenti ricorrenti tokenizzati (es. Stripe, PayPal adeguato, ecc.). 
WordPress.org

Plugin ufficiale WooCommerce Subscriptions (alternativa)
Esiste un plugin ufficiale e premium chiamato WooCommerce Subscriptions che √® pi√π completo e affidabile per modelli di pagamenti mensili e ricorrenti completi. Questo per√≤ √® a pagamento. 
WooCommerce

üìå Se stai cercando una soluzione gratuita o pi√π semplice ‚Üí ‚ÄúSubscriptions for WooCommerce‚Äù √® quello giusto.
üìå Se invece ti serve affidabilit√† massima, compatibilit√† con molti gateway e funzioni avanzate di subscription management ‚Üí la scelta standard √® WooCommerce Subscriptions (a pagamento). 
WooCommerce

Se vuoi, posso consigliarti le differenze principali tra questi plugin (funzionalit√†, compatibilit√† gateway, costi ecc.) per aiutarti a scegliere in base alle tue esigenze di e-commerce.

Hai detto:
Immagine caricata
ChatGPT ha detto:
Perfetto, lo screenshot chiarisce tutto üëç
Questo NON √® un errore fatale: √® un classico problema di capability / permessi WordPress.

Messaggio chiave:

‚ÄúSorry, you are not allowed to access this page.‚Äù

Significa che la pagina admin del plugin esiste, ma l‚Äôutente loggato non ha la capability richiesta per accedervi.

üîé Perch√© succede (nel tuo caso specifico)
Il menu ipv-vendor viene registrato con qualcosa tipo:

add_menu_page(
    'IPV Vendor',
    'IPV Vendor',
    'manage_options', // üëà QUI
    'ipv-vendor',
    ...
);
Se:

non sei Administrator

oppure stai usando un ruolo custom

oppure il plugin usa una capability non assegnata

WordPress blocca l‚Äôaccesso ‚Üí messaggio che vedi nello screenshot.

‚úÖ Soluzioni (in ordine di pulizia)
‚úÖ 1. Verifica immediata (2 minuti)
Assicurati che l‚Äôutente con cui sei loggato sia:

Amministratore

non un ruolo custom / editor / shop manager

üëâ Se anche da admin vedi il blocco ‚Üí vai al punto 2.

‚úÖ 2. FIX corretto nel plugin (consigliato)
Nel file dove registri il menu (probabilmente class-vendor-admin.php o class-vendor-core.php):

üî¥ ORA probabilmente hai:
$capability = 'manage_options';
üü¢ Sostituisci con:
$capability = 'manage_woocommerce';
oppure (ancora pi√π sicuro per vendor system):

$capability = 'read';
Esempio completo:

add_menu_page(
    'IPV Vendor',
    'IPV Vendor',
    'manage_woocommerce',
    'ipv-vendor',
    [$this, 'render_page'],
    'dashicons-admin-network',
    56
);
üìå manage_woocommerce:

ce l‚Äôhanno Admin

ce l‚Äôhanno Shop Manager

perfetto per vendor / SaaS / licensing

‚úÖ 3. FIX ‚Äúblindato‚Äù anti-futuri errori
Subito prima del render, aggiungi un controllo esplicito:

if ( ! current_user_can( 'manage_woocommerce' ) ) {
    wp_die( __( 'Accesso non consentito.', 'ipv-vendor' ) );
}
Cos√¨:

niente pagine bianche

niente messaggi generici WordPress

controllo chiaro

‚ùå Cosa NON √®
Cos√¨ eviti di perdere tempo:

‚ùå non √® un problema di routing

‚ùå non √® un problema di nonce

‚ùå non √® un problema di rewrite

‚ùå non √® collegato ai warning PHP deprecated

√à solo capability mismatch.

üîß Se vuoi, te lo sistemo io ‚Äúdefinitivo‚Äù
Se mi dici:

in quale file registri il menu (add_menu_page)

che ruoli devono accedere (Admin / Shop Manager / Vendor)

ti preparo:

capability custom ipv_vendor_manage

assegnazione automatica ai ruoli

fallback sicuro

üëâ cos√¨ il pannello non ti si rompe mai pi√π, anche cambiando hosting / PHP / utenti.

Hai detto:
sono admin
ChatGPT ha detto:

Ragionato per 3m 46s
Se sei admin e vedi comunque ‚ÄúSorry, you are not allowed‚Ä¶‚Äù, allora non √® un problema di ruolo: nello screenshot stai aprendo questa URL:

/wp-admin/admin.php?page=ipv-vendor

‚úÖ Nel plugin che hai installato, la pagina NON si chiama pi√π ipv-vendor ma:

/wp-admin/admin.php?page=ipv-vendor-dashboard

Quindi WordPress non trova la pagina registrata e ti mostra quel messaggio (anche da admin).

Cosa fare subito
Prova ad aprire direttamente:
/wp-admin/admin.php?page=ipv-vendor-dashboard

Nel menu a sinistra dovresti vedere ‚ÄúIPV Pro Vendor‚Äù ‚Üí clicca l√¨.

Fix definitivo (alias automatico)
Per evitare che bookmark/vecchi link continuino a rompere, ho preparato un aggiornamento che reindirizza automaticamente da page=ipv-vendor a page=ipv-vendor-dashboard.

üì¶ Scarica e installa questo ZIP sopra il plugin attuale:

Download ipv-pro-vendor-server-v1.4.0-optimized-autoinstaller-FIXED2-legacy-alias.zip

Dopo l‚Äôupdate, anche se apri admin.php?page=ipv-vendor, ti porta da solo al dashboard corretto.

Se dopo questo non vedi ancora il menu, dimmi se √® un multisite (network) perch√© l√¨ cambiano i permessi e potremmo dover agganciare anche network_admin_menu.

Hai detto:
un nome piu breve?
ChatGPT ha detto:
Certo. Ecco opzioni brevi e pulite (stile plugin WP):

ipv-vendor-1.4.0-fix2.zip

ipv-vendor-1.4.0-alias.zip

ipv-vendor-fix-alias.zip

ipv-vendor-hotfix.zip

ipv-vendor-legacy-alias.zip

Se vuoi il pi√π corto in assoluto: ipv-vendor-hotfix.zip.

Hai detto:
chiamalo 1.4.1
ChatGPT ha detto:
Perfetto üëç
Allora il nome definitivo √®:

ipv-vendor-1.4.1.zip

Versioning corretto, chiaro e coerente con il fix (bug + backward compatibility).
Da ora in poi puoi considerare 1.4.1 come stable.

Se vuoi, nel prossimo step possiamo:

allineare versione plugin + constant + changelog

oppure fare 1.4.2 per pulire i deprecated PHP 8.2+

oppure agganciare Woo Subscriptions direttamente al vendor system (mensile SaaS vero)

Dimmi tu üëâ

Hai detto:
lo installo su woocommerce in un secondo momento, lasciami il wizard per la creazione dei prodotti, se il plugin non √® presente fai solo i prodotti annuali
ChatGPT ha detto:

Ragionato per 17s
Ok ‚úÖ: lasciamo il wizard dentro IPV Vendor per creare i prodotti, ma con questa logica:

Se NON c‚Äô√® un plugin Subscriptions attivo ‚Üí il wizard crea solo i prodotti annuali come prodotti semplici (pagamento una tantum).

Se c‚Äô√® un plugin Subscriptions attivo (WooCommerce Subscriptions ufficiale oppure ‚ÄúSubscriptions for WooCommerce‚Äù) ‚Üí il wizard abilita anche mensile (e opzionalmente converte/aggancia l‚Äôannuale come ‚Äúsubscription annuale‚Äù).

Comportamento del wizard (chiaro e senza sorprese)
Step 1 ‚Äî Scelta ‚ÄúPiani‚Äù
Mostra:

‚úÖ Annuale (sempre disponibile)

üîí Mensile (disabilitato + badge ‚Äúrichiede plugin Subscriptions‚Äù) se manca il plugin

Step 2 ‚Äî Prezzi e nomi
Annuale: prezzo annuo, nome prodotto, SKU base, categoria

Mensile: appare solo se Subscriptions √® attivo

Step 3 ‚Äî Creazione prodotti
Crea/aggiorna:

IPV Vendor ‚Äì Annual (sempre)

IPV Vendor ‚Äì Monthly (solo se Subscriptions attivo)

Rilevamento automatico plugin Subscriptions
Nel codice del wizard fai un check ‚Äúprovider‚Äù:

function ipv_vendor_has_subscriptions(): bool {
    // WooCommerce Subscriptions ufficiale
    if ( class_exists('WC_Subscriptions') || function_exists('wcs_create_renewal_order') ) {
        return true;
    }

    // Altri plugin subscription (fallback generico)
    if ( class_exists('WCSwings_Subscriptions_For_WooCommerce') || class_exists('Subscriptions_For_WooCommerce') ) {
        return true;
    }

    return false;
}
Se vuoi essere ancora pi√π solido: controlliamo anche is_plugin_active() con slug, ma cos√¨ gi√† funziona senza dipendenze.

Creazione prodotti: annuale ‚Äúsemplice‚Äù se manca Subscriptions
function ipv_vendor_create_or_update_annual_simple($args) {
    $product_id = ipv_find_product_by_sku($args['sku_annual']);

    $product = $product_id ? wc_get_product($product_id) : new WC_Product_Simple();

    $product->set_name($args['name_annual']);
    $product->set_sku($args['sku_annual']);
    $product->set_regular_price($args['price_annual']);
    $product->set_virtual(true);
    $product->set_downloadable(false);
    $product->set_catalog_visibility('visible');
    $product->set_status('publish');

    // Tag utile per riconoscerli sempre
    $product->update_meta_data('_ipv_vendor_plan', 'annual');
    $product->update_meta_data('_ipv_vendor_managed', 'yes');

    return $product->save();
}
Cos√¨ vendi annuale subito anche senza subscription plugin.

Quando installerai Subscriptions ‚Äúin un secondo momento‚Äù
Il wizard resta uguale, ma:

si sblocca Mensile

l‚Äôannuale pu√≤ restare ‚Äúsimple‚Äù (pagamento una tantum) oppure puoi aggiungere un toggle: ‚ÄúAnnuale come abbonamento‚Äù.

Io ti consiglio di default:

Mensile = subscription

Annuale = semplice (pi√π robusto, meno rogne gateway)

opzionale: Annuale subscription per chi lo vuole.

Nota importante (per non spaccare gli acquisti gi√† fatti)
Nel wizard NON ‚Äúconvertire‚Äù automaticamente prodotti esistenti da simple ‚Üí subscription.
Meglio:

se esiste annuale simple, lo lasci com‚Äô√®

crei un nuovo prodotto ‚ÄúAnnual Subscription‚Äù solo se l‚Äôutente lo seleziona

Se mi dici nome dei piani (Starter/Pro/Business) e se vuoi varianti per crediti (10/25/100/500 al mese), ti scrivo lo schema esatto che il wizard deve generare (SKU, nomi, prezzi, meta _ipv_*) cos√¨ poi quando attivi Subscriptions si aggancia senza cambiare nulla lato vendor/licenze.

Hai detto:
trial starter pro business piu "acquisto golden prompt". piu "acquisto crediti extra a 0,39 cent euro"
ChatGPT ha detto:

Ragionato per un paio di secondi
Perfetto. Nel wizard ti imposto 2 ‚Äúmodalit√†‚Äù automatiche:

Senza Subscriptions installato ‚Üí crea SOLO prodotti annuali (pagamento una tantum) per: Trial, Starter, Pro, Business.

Con Subscriptions installato ‚Üí abilita anche i mensili (Trial/Starter/Pro/Business) + mantiene gli annuali.

In pi√π, sempre (a prescindere da Subscriptions):

Acquisto ‚ÄúGolden Prompt‚Äù = prodotto una tantum

Acquisto crediti extra = prodotto una tantum con prezzo ‚Ç¨0,39 per credito (quantit√† = numero crediti)

1) Piani: Trial / Starter / Pro / Business
Struttura prodotti che crea il wizard
Per ogni piano crei (almeno) l‚ÄôANNUALE:

IPV ‚Äì Trial (Annual)

IPV ‚Äì Starter (Annual)

IPV ‚Äì Pro (Annual)

IPV ‚Äì Business (Annual)

Se Subscriptions √® presente, in pi√π:

IPV ‚Äì Trial (Monthly)

IPV ‚Äì Starter (Monthly)

IPV ‚Äì Pro (Monthly)

IPV ‚Äì Business (Monthly)

SKU consigliate (semplici e stabili)
Annuali: IPV-TRIAL-Y, IPV-STARTER-Y, IPV-PRO-Y, IPV-BUSINESS-Y

Mensili: IPV-TRIAL-M, IPV-STARTER-M, IPV-PRO-M, IPV-BUSINESS-M

Meta fondamentali (cos√¨ il vendor/licenze lavora ‚Äúpulito‚Äù)
Su ogni prodotto piano salva:

_ipv_vendor_plan = trial|starter|pro|business

_ipv_vendor_period = annual|monthly

_ipv_vendor_credits_per_month = (numero)

_ipv_vendor_features = JSON (flags tipo transcript/thumbs/descrizioni ecc.)

_ipv_vendor_managed = yes

Nota: anche gli annual possono avere ‚Äúcredits_per_month‚Äù: tu li gestisci lato vendor resettandoli mensilmente comunque (anche se il pagamento √® annuale).

2) ‚ÄúAcquisto Golden Prompt‚Äù (one-shot)
Prodotto semplice (no subscription):

Nome: IPV ‚Äì Golden Prompt (One-time)

SKU: IPV-GOLDENPROMPT

Meta:

_ipv_vendor_addon = golden_prompt

_ipv_vendor_grants = JSON tipo { "golden_prompt": true }

Comportamento al pagamento:

assegni al license/account l‚Äôaddon ‚ÄúGolden Prompt‚Äù (per sempre o per durata licenza: come preferisci).

3) ‚ÄúCrediti extra‚Äù a ‚Ç¨0,39/credito (one-shot)
Prodotto semplice, venduto a unit√†:

Nome: IPV ‚Äì Extra Credits

SKU: IPV-CREDITS-EXTRA

Prezzo: 0,39

Quantit√† abilitata (il cliente mette 10 = 10 crediti)

Impostazioni:

Virtuale: s√¨

Venduto singolarmente: no

Meta:

_ipv_vendor_addon = extra_credits

_ipv_vendor_credit_unit_price = 0.39

Comportamento al pagamento:

crediti_da_aggiungere = quantit√† acquistata

li sommi al saldo crediti della licenza/account.

4) UX del wizard (senza spaccarti il flusso)
Wizard step ‚ÄúPiani‚Äù:

mostra sempre Trial/Starter/Pro/Business Annual

mostra Mensile solo se detect subscriptions = true (altrimenti toggle disabilitato con label ‚Äúattiva Subscriptions per mensile‚Äù)

Wizard step ‚ÄúAddon‚Äù:

checkbox: ‚ÄúCrea prodotto Golden Prompt‚Äù

checkbox: ‚ÄúCrea prodotto Crediti Extra (‚Ç¨0,39/credito)‚Äù

Wizard step ‚ÄúRiepilogo‚Äù:

lista prodotti che verranno creati/aggiornati + SKU + prezzo

5) Mi serve solo 2 valori da te (per impostarlo ‚Äúchiavi in mano‚Äù)
Non ti faccio domande lunghe: dimmi solo questi 2 numeri e io ti preparo la tabella completa per i 4 piani:

Crediti/mese per Trial, Starter, Pro, Business (esempio: 10 / 25 / 100 / 500)

Prezzo annuale per Trial, Starter, Pro, Business

Se non me li dai subito, imposto default ‚Äúneutri‚Äù (0 crediti e prezzo a tua scelta nel wizard), ma √® meglio se li decidiamo adesso cos√¨ il wizard genera gi√† tutto pronto.

Hai detto:
il trial √® solo mensile
ChatGPT ha detto:
Perfetto: allora il wizard fa cos√¨ (senza ambiguit√†):

Regola Trial
Trial = SOLO mensile

Niente annuale per Trial, mai.

Quindi:
Se Subscriptions NON √® installato ‚Üí Trial non viene creato (perch√© non potresti fare rinnovo mensile).
Nel wizard lo mostri grigio/disabilitato con testo: ‚ÄúTrial disponibile solo con plugin Subscriptions‚Äù.

Se Subscriptions √® installato ‚Üí crei IPV ‚Äì Trial (Monthly).

SKU trial mensile: IPV-TRIAL-M

Meta:

_ipv_vendor_plan = trial

_ipv_vendor_period = monthly

_ipv_vendor_credits_per_month = X (come definisci tu)

_ipv_vendor_is_trial = yes (utile per logiche extra)

Regola Starter / Pro / Business
Sempre annuali (anche senza Subscriptions)

Mensili solo se Subscriptions √® installato

SKU:

Starter: IPV-STARTER-Y (+ IPV-STARTER-M se subs)

Pro: IPV-PRO-Y (+ IPV-PRO-M se subs)

Business: IPV-BUSINESS-Y (+ IPV-BUSINESS-M se subs)

Add-on sempre disponibili
IPV ‚Äì Golden Prompt (One-time) SKU IPV-GOLDENPROMPT

IPV ‚Äì Extra Credits SKU IPV-CREDITS-EXTRA prezzo unit√† 0,39 con quantit√† = crediti

Se mi dai crediti/mese per Trial/Starter/Pro/Business e i prezzi annuali (starter/pro/business) + prezzi mensili (trial/starter/pro/business quando attivi subscriptions), ti imposto la matrice finale che il wizard genera al 100% (nomi, SKU, meta, reset crediti).

Hai detto:
la trial ha 5 crediti e puo acquistare crediti, deve poterlo acquistare dal my account una volta loggato. servir√† area dedicata al acquisto, ogni acquisto √® legato alla license key e il valore acuistato andr√† aggiunto al totale dei credit/video del account

starter 30 video 9,99 euro al mese - anno 99 euro
pro 75 video 19,99 euro al mese - anno 219 euro
business 150 video 39,99 euro al mese - anno 439 euro
1 video - 0,35 cent euro minimo 10


ChatGPT ha detto:
Perfetto, adesso il quadro √® chiaro e definitivo. Ti restituisco architettura + regole operative pronte per essere implementate nel wizard e nel vendor system, senza ambiguit√†.

üéØ STRUTTURA FINALE IPV VENDOR (v1.4.1+)
üîë CONCETTO CHIAVE (importantissimo)
TUTTO √® legato a una LICENSE KEY

Ogni acquisto (abbonamento o crediti extra):

viene associato alla license key attiva

incrementa il totale crediti/video dell‚Äôaccount

I crediti sono crediti/video (1 credito = 1 video)

1Ô∏è‚É£ TRIAL (solo mensile, obbligatorio)
Trial ‚Äì regole
‚úÖ Solo mensile

‚úÖ 5 crediti/video inclusi

‚úÖ PU√í acquistare crediti extra

‚ùå Nessuna versione annuale

‚ùå Non esiste senza Subscriptions

Prodotto WooCommerce
Nome: IPV ‚Äì Trial (Monthly)

SKU: IPV-TRIAL-M

Tipo:

Subscription mensile

Prezzo: (puoi anche metterlo 0‚Ç¨ o simbolico)

Meta:

_ipv_vendor_plan = trial
_ipv_vendor_period = monthly
_ipv_vendor_credits_per_month = 5
_ipv_vendor_is_trial = yes
_ipv_vendor_can_buy_credits = yes
2Ô∏è‚É£ PIANI PRINCIPALI
Starter
30 video / mese

9,99 ‚Ç¨ / mese

99 ‚Ç¨ / anno

Pro
75 video / mese

19,99 ‚Ç¨ / mese

219 ‚Ç¨ / anno

Business
150 video / mese

39,99 ‚Ç¨ / mese

439 ‚Ç¨ / anno

Prodotti generati dal wizard
SENZA Subscriptions installato
üëâ SOLO ANNUALI (pagamento una tantum)

IPV ‚Äì Starter (Annual) ‚Üí 99 ‚Ç¨

IPV ‚Äì Pro (Annual) ‚Üí 219 ‚Ç¨

IPV ‚Äì Business (Annual) ‚Üí 439 ‚Ç¨

I crediti vengono resettati ogni mese comunque, anche se il pagamento √® annuale.

CON Subscriptions installato
üëâ Mensile + Annuale

Mensili (subscription):

IPV ‚Äì Starter (Monthly) ‚Üí 9,99 ‚Ç¨

IPV ‚Äì Pro (Monthly) ‚Üí 19,99 ‚Ç¨

IPV ‚Äì Business (Monthly) ‚Üí 39,99 ‚Ç¨

Annuali (simple):

Starter / Pro / Business come sopra

Meta comuni (fondamentali)
_ipv_vendor_plan = starter|pro|business
_ipv_vendor_period = monthly|annual
_ipv_vendor_credits_per_month = 30|75|150
_ipv_vendor_managed = yes
3Ô∏è‚É£ CREDITI EXTRA (CORE DEL TUO MODELLO)
Regole
üí∞ 0,35 ‚Ç¨ per 1 video

üî¢ Minimo acquisto: 10 video

‚ûï I crediti acquistati:

si SOMMANO al totale account

non scadono

üîë Ogni acquisto √® legato alla license key selezionata

Prodotto WooCommerce
Nome: IPV ‚Äì Crediti Extra

SKU: IPV-CREDITS-EXTRA

Tipo: Prodotto semplice

Prezzo: 0,35 ‚Ç¨

Quantit√†: ABILITATA

Quantit√† minima: 10

Meta:

_ipv_vendor_addon = extra_credits
_ipv_vendor_credit_unit_price = 0.35
_ipv_vendor_min_quantity = 10
4Ô∏è‚É£ AREA ‚ÄúMY ACCOUNT‚Äù (fondamentale)
Nuova sezione:
üëâ My Account ‚Üí IPV Credits

Contenuto:
License key attiva (o selector se ne ha pi√π di una)

Crediti disponibili

Crediti mensili inclusi dal piano

Crediti extra acquistati

Pulsante:
‚ÄúAcquista crediti extra‚Äù

Flusso acquisto crediti
Utente loggato

Seleziona license key

Inserisce quantit√† (min 10)

Checkout

Al pagamento:

crediti = quantit√†_acquistata
ipv_vendor_add_credits( license_key, crediti );
üëâ Nessun credito ‚Äúperso‚Äù, nessun reset sugli extra.

5Ô∏è‚É£ LOGICA VENDOR (riassunto tecnico)
Ogni account/license ha:
credits_monthly
credits_extra
credits_total = monthly + extra
Reset mensile (cron)
reset SOLO credits_monthly

credits_extra resta intatto

6Ô∏è‚É£ WIZARD ‚Äì COSA FA ESATTAMENTE
Step 1 ‚Äì Piani
Trial (solo se Subscriptions attivo)

Starter / Pro / Business

Toggle Mensile / Annuale (mensile solo se Subscriptions)

Step 2 ‚Äì Prezzi (precompilati)
come da tabella sopra (editabili)

Step 3 ‚Äì Add-on
‚òëÔ∏è Crea prodotto ‚ÄúCrediti Extra‚Äù

‚òëÔ∏è (opzionale) Golden Prompt

Step 4 ‚Äì Conferma
Elenco prodotti + SKU + prezzi

‚ÄúCrea / Aggiorna prodotti‚Äù

üî• Questa struttura √® PERFETTA perch√©
funziona anche senza Subscriptions

scala a SaaS vero

i crediti diventano moneta interna

Trial non rompe nulla

My Account diventa punto di monetizzazione continua

Prossimo step (dimmi tu)
Posso:

Disegnarti la UI My Account (wireframe logico)

Scriverti la funzione PHP completa ipv_vendor_add_credits()

Prepararti le query DB per licenze + crediti

Integrare Webhook Woo ‚Üí Vendor (robusto)

Dimmi il prossimo passo e andiamo avanti üî•

Hai detto:
vogio tutto
ChatGPT ha detto:
Ok. Ti lascio tutto: struttura plugin, DB, wizard prodotti, My Account ‚ÄúIPV Credits‚Äù, acquisto crediti extra con minimo 10, legame ordine ‚Üí license key, accredito automatico, reset mensile crediti inclusi, e (quando installerai Subscriptions) supporto mensile + trial.

Di seguito √® scritto in modo che tu (o un dev) possa incollare e mettere online senza inventarsi nulla.

0) Struttura dati (DB) ‚Äî solida e semplice
Tabella licenze
wp_ipv_licenses

Campi consigliati:

id BIGINT PK

license_key VARCHAR(64) UNIQUE

user_id BIGINT

plan ENUM('trial','starter','pro','business')

status ENUM('active','paused','expired')

period ENUM('monthly','annual')

credits_monthly INT DEFAULT 0

credits_extra INT DEFAULT 0

credits_used_month INT DEFAULT 0

renewal_date DATETIME NULL (se vuoi)

created_at DATETIME

updated_at DATETIME

Crediti disponibili = credits_monthly + credits_extra - credits_used_month (oppure separi ‚Äúused‚Äù in log).

Tabella movimenti crediti (ledger)
wp_ipv_credit_ledger

id BIGINT PK

license_key VARCHAR(64)

user_id BIGINT

type ENUM('grant_monthly','grant_extra','consume','adjust','refund')

amount INT (positivo/negativo)

ref_type VARCHAR(32) (order|cron|api)

ref_id VARCHAR(64) (order_id ecc.)

note TEXT NULL

created_at DATETIME

Il ledger ti salva il culo: contabilit√† crediti tracciabile, rimborsi, debugging.

1) Matrice piani (definitiva)
Trial (SOLO mensile)
5 video/mese

pu√≤ acquistare crediti extra

Starter
30 video/mese

9,99 ‚Ç¨/mese

99 ‚Ç¨/anno

Pro
75 video/mese

19,99 ‚Ç¨/mese

219 ‚Ç¨/anno

Business
150 video/mese

39,99 ‚Ç¨/mese

439 ‚Ç¨/anno

Crediti extra
0,35 ‚Ç¨/video

minimo 10

2) Identit√† prodotti (SKU stabili)
Mensili (subscription, solo se Subscriptions presente)
IPV-TRIAL-M

IPV-STARTER-M

IPV-PRO-M

IPV-BUSINESS-M

Annuali (semplici, sempre creati)
IPV-STARTER-Y

IPV-PRO-Y

IPV-BUSINESS-Y

Add-on
Crediti extra: IPV-CREDITS-EXTRA (unit√† = 1 credito)

Golden Prompt: IPV-GOLDENPROMPT

3) Wizard ‚ÄúCrea Prodotti‚Äù (sempre nel vendor)
Regole wizard
Se Subscriptions NON presente:

crea SOLO annuali (Starter/Pro/Business)

Trial mensile non viene creato (mostrato disabilitato)

crea sempre ‚ÄúCrediti extra‚Äù e ‚ÄúGolden Prompt‚Äù se spunti

Se Subscriptions presente:

crea mensili (Trial + Starter/Pro/Business)

crea anche annuali

Funzione detection subscriptions
function ipv_vendor_has_subscriptions(): bool {
    // WooCommerce Subscriptions ufficiale
    if ( class_exists('WC_Subscriptions') || function_exists('wcs_create_renewal_order') ) return true;

    // WCSwings / altri: fallback soft
    if ( class_exists('WCSwings_Subscriptions_For_WooCommerce') ) return true;

    return false;
}
4) Prodotto ‚ÄúCrediti Extra‚Äù con minimo 10 (Woo)
Validazione in carrello
add_action('woocommerce_check_cart_items', function () {
    if ( ! WC()->cart ) return;

    foreach ( WC()->cart->get_cart() as $item ) {
        $product = $item['data'];
        if ( ! $product ) continue;

        if ( $product->get_sku() === 'IPV-CREDITS-EXTRA' ) {
            $qty = (int) $item['quantity'];
            if ( $qty < 10 ) {
                wc_add_notice('Minimo acquisto crediti: 10 video.', 'error');
            }
        }
    }
});
Prezzo unitario 0,35 sempre (anti-manomissione)
add_action('woocommerce_before_calculate_totals', function($cart){
    if ( is_admin() && ! defined('DOING_AJAX') ) return;
    if ( ! $cart ) return;

    foreach ($cart->get_cart() as $item) {
        if (!isset($item['data'])) continue;
        $p = $item['data'];
        if ( $p->get_sku() === 'IPV-CREDITS-EXTRA' ) {
            $p->set_price(0.35);
        }
    }
}, 20);
5) ‚ÄúMy Account ‚Üí IPV Credits‚Äù (area dedicata + acquisto)
Endpoint My Account
URL: /my-account/ipv-credits/

add_action('init', function () {
    add_rewrite_endpoint('ipv-credits', EP_ROOT | EP_PAGES);
});

add_filter('woocommerce_account_menu_items', function($items){
    // Inseriscilo dove vuoi
    $items['ipv-credits'] = 'IPV Credits';
    return $items;
});

add_action('woocommerce_account_ipv-credits_endpoint', function () {
    if ( ! is_user_logged_in() ) {
        echo '<p>Devi essere loggato.</p>';
        return;
    }

    $user_id = get_current_user_id();
    $licenses = ipv_vendor_get_user_licenses($user_id); // tua funzione DB

    echo '<h2>IPV Credits</h2>';

    if ( empty($licenses) ) {
        echo '<p>Nessuna license attiva trovata.</p>';
        return;
    }

    // Selector license
    $selected = isset($_GET['license']) ? sanitize_text_field($_GET['license']) : $licenses[0]['license_key'];
    $license = ipv_vendor_get_license($selected);

    echo '<form method="get" style="margin:12px 0;">';
    echo '<label><strong>Seleziona license:</strong></label><br>';
    echo '<select name="license" onchange="this.form.submit()">';
    foreach ($licenses as $l) {
        $k = esc_attr($l['license_key']);
        $sel = selected($selected, $l['license_key'], false);
        echo "<option value='{$k}' {$sel}>{$k} ({$l['plan']})</option>";
    }
    echo '</select>';
    echo '</form>';

    $available = ipv_vendor_get_available_credits($selected);

    echo '<p><strong>Piano:</strong> '.esc_html($license['plan']).' ('.esc_html($license['period']).')</p>';
    echo '<p><strong>Crediti disponibili:</strong> '.intval($available).'</p>';
    echo '<p><strong>Crediti mensili:</strong> '.intval($license['credits_monthly']).'</p>';
    echo '<p><strong>Crediti extra:</strong> '.intval($license['credits_extra']).'</p>';

    // CTA acquisto crediti
    $credits_product_id = ipv_vendor_find_product_id_by_sku('IPV-CREDITS-EXTRA');
    if ($credits_product_id) {
        $url = add_query_arg([
            'add-to-cart' => $credits_product_id,
            'ipv_license' => $selected,
        ], wc_get_cart_url());

        echo '<hr>';
        echo '<h3>Acquista crediti extra</h3>';
        echo '<p>Prezzo: <strong>‚Ç¨0,35</strong> per video (minimo 10).</p>';
        echo '<a class="button" href="'.esc_url($url).'">Aggiungi al carrello</a>';
    } else {
        echo '<p><em>Prodotto crediti extra non trovato (SKU IPV-CREDITS-EXTRA).</em></p>';
    }
});
Quando l‚Äôutente aggiunge al carrello dal My Account
Salvi la license nel cart item:

add_filter('woocommerce_add_cart_item_data', function($cart_item_data, $product_id){
    $product = wc_get_product($product_id);
    if ( ! $product ) return $cart_item_data;

    if ( $product->get_sku() === 'IPV-CREDITS-EXTRA' && isset($_GET['ipv_license']) ) {
        $cart_item_data['ipv_license'] = sanitize_text_field($_GET['ipv_license']);
    }
    return $cart_item_data;
}, 10, 2);

add_filter('woocommerce_get_item_data', function($item_data, $cart_item){
    if ( isset($cart_item['ipv_license']) ) {
        $item_data[] = [
            'name'  => 'License',
            'value' => esc_html($cart_item['ipv_license']),
        ];
    }
    return $item_data;
}, 10, 2);
Obbligo license key se compri crediti
add_action('woocommerce_check_cart_items', function(){
    if ( ! WC()->cart ) return;

    foreach ( WC()->cart->get_cart() as $item ) {
        $p = $item['data'] ?? null;
        if ( ! $p ) continue;

        if ( $p->get_sku() === 'IPV-CREDITS-EXTRA' ) {
            if ( empty($item['ipv_license']) ) {
                wc_add_notice('Seleziona una license per acquistare crediti extra (dal tuo My Account).', 'error');
            }
        }
    }
});
6) Accredito automatico crediti extra dopo pagamento (legato a license)
Quando ordine passa a ‚Äúprocessing/completed‚Äù:

add_action('woocommerce_order_status_completed', 'ipv_vendor_handle_order_credits');
add_action('woocommerce_order_status_processing', 'ipv_vendor_handle_order_credits');

function ipv_vendor_handle_order_credits($order_id){
    $order = wc_get_order($order_id);
    if ( ! $order ) return;

    foreach ( $order->get_items() as $item_id => $item ) {
        $product = $item->get_product();
        if ( ! $product ) continue;

        if ( $product->get_sku() === 'IPV-CREDITS-EXTRA' ) {
            $qty = (int) $item->get_quantity(); // 1 qty = 1 credito
            $license = $item->get_meta('ipv_license');

            // Se non c'√® sull'item, prova a leggere dal cart meta salvato in order
            if ( ! $license ) {
                $license = $order->get_meta('_ipv_license');
            }

            if ( ! $license || $qty <= 0 ) continue;

            // idempotenza: evita doppio accredito
            $already = $order->get_meta('_ipv_credits_granted_'.$item_id);
            if ( $already ) continue;

            ipv_vendor_add_credits($license, $qty, 'order', (string)$order_id, 'Acquisto crediti extra');
            $order->update_meta_data('_ipv_credits_granted_'.$item_id, 1);
            $order->save();
        }
    }
}
E salva la license nell‚Äôorder item quando crei l‚Äôordine:

add_action('woocommerce_checkout_create_order_line_item', function($item, $cart_item_key, $values, $order){
    $product = $item->get_product();
    if ( $product && $product->get_sku() === 'IPV-CREDITS-EXTRA' && !empty($values['ipv_license']) ) {
        $item->add_meta_data('ipv_license', $values['ipv_license'], true);
        // opzionale copia anche in order meta
        $order->update_meta_data('_ipv_license', $values['ipv_license']);
    }
}, 10, 4);
7) Funzioni DB core (da mettere in includes/db.php)
function ipv_vendor_get_user_licenses($user_id){
    global $wpdb;
    $t = $wpdb->prefix.'ipv_licenses';
    return $wpdb->get_results($wpdb->prepare("SELECT * FROM {$t} WHERE user_id=%d AND status='active' ORDER BY created_at DESC", $user_id), ARRAY_A);
}

function ipv_vendor_get_license($license_key){
    global $wpdb;
    $t = $wpdb->prefix.'ipv_licenses';
    return $wpdb->get_row($wpdb->prepare("SELECT * FROM {$t} WHERE license_key=%s LIMIT 1", $license_key), ARRAY_A);
}

function ipv_vendor_get_available_credits($license_key){
    $lic = ipv_vendor_get_license($license_key);
    if (!$lic) return 0;
    $monthly = (int)$lic['credits_monthly'];
    $extra   = (int)$lic['credits_extra'];
    $used    = (int)$lic['credits_used_month'];
    $avail = ($monthly + $extra) - $used;
    return max(0, $avail);
}

function ipv_vendor_add_credits($license_key, $amount, $ref_type='adjust', $ref_id='', $note=''){
    global $wpdb;
    $tL = $wpdb->prefix.'ipv_licenses';
    $tG = $wpdb->prefix.'ipv_credit_ledger';

    $lic = ipv_vendor_get_license($license_key);
    if (!$lic) return false;

    $amount = (int)$amount;
    if ($amount <= 0) return false;

    // Accredita EXTRA
    $wpdb->query($wpdb->prepare("UPDATE {$tL} SET credits_extra = credits_extra + %d, updated_at = NOW() WHERE license_key=%s", $amount, $license_key));

    $wpdb->insert($tG, [
        'license_key' => $license_key,
        'user_id'     => (int)$lic['user_id'],
        'type'        => 'grant_extra',
        'amount'      => $amount,
        'ref_type'    => $ref_type,
        'ref_id'      => $ref_id,
        'note'        => $note,
        'created_at'  => current_time('mysql'),
    ]);

    return true;
}

function ipv_vendor_grant_monthly_credits($license_key, $monthly_amount, $ref_id='cron'){
    global $wpdb;
    $tL = $wpdb->prefix.'ipv_licenses';
    $tG = $wpdb->prefix.'ipv_credit_ledger';

    $lic = ipv_vendor_get_license($license_key);
    if (!$lic) return false;

    $monthly_amount = (int)$monthly_amount;

    // reset used + set monthly
    $wpdb->query($wpdb->prepare("
        UPDATE {$tL}
        SET credits_monthly=%d, credits_used_month=0, updated_at=NOW()
        WHERE license_key=%s
    ", $monthly_amount, $license_key));

    $wpdb->insert($tG, [
        'license_key' => $license_key,
        'user_id'     => (int)$lic['user_id'],
        'type'        => 'grant_monthly',
        'amount'      => $monthly_amount,
        'ref_type'    => 'cron',
        'ref_id'      => $ref_id,
        'note'        => 'Reset mensile crediti inclusi',
        'created_at'  => current_time('mysql'),
    ]);

    return true;
}
8) Reset mensile crediti inclusi (cron)
Ogni 1¬∞ del mese (o ogni 30 giorni, scegli tu):

add_action('ipv_vendor_monthly_reset', function(){
    global $wpdb;
    $t = $wpdb->prefix.'ipv_licenses';

    $rows = $wpdb->get_results("SELECT license_key, plan, status FROM {$t} WHERE status='active'", ARRAY_A);
    foreach ($rows as $r) {
        $plan = $r['plan'];
        $monthly = ipv_vendor_plan_monthly_credits($plan);
        ipv_vendor_grant_monthly_credits($r['license_key'], $monthly, 'monthly_reset');
    }
});

function ipv_vendor_plan_monthly_credits($plan){
    switch($plan){
        case 'trial': return 5;
        case 'starter': return 30;
        case 'pro': return 75;
        case 'business': return 150;
        default: return 0;
    }
}

register_activation_hook(__FILE__, function(){
    if ( ! wp_next_scheduled('ipv_vendor_monthly_reset') ) {
        // 1¬∞ giorno prossimo mese alle 02:15
        $ts = strtotime('first day of next month 02:15:00');
        wp_schedule_event($ts, 'monthly', 'ipv_vendor_monthly_reset');
    }
});

register_deactivation_hook(__FILE__, function(){
    $ts = wp_next_scheduled('ipv_vendor_monthly_reset');
    if ($ts) wp_unschedule_event($ts, 'ipv_vendor_monthly_reset');
});
9) Creazione / aggiornamento licenza dopo acquisto piano (Woo)
Regola:

se compra Starter/Pro/Business (annual o monthly) ‚Üí crea/aggiorna license

setta plan, period, status=active

applica credits_monthly secondo piano + reset used

extra resta intatto

Hook ordine:

add_action('woocommerce_order_status_completed', 'ipv_vendor_handle_plan_purchase', 5);
add_action('woocommerce_order_status_processing', 'ipv_vendor_handle_plan_purchase', 5);

function ipv_vendor_handle_plan_purchase($order_id){
    $order = wc_get_order($order_id);
    if (!$order) return;

    $user_id = $order->get_user_id();
    if (!$user_id) return;

    foreach ($order->get_items() as $item_id => $item) {
        $p = $item->get_product();
        if (!$p) continue;

        $sku = $p->get_sku();
        $plan = null; $period = null;

        if ($sku === 'IPV-STARTER-Y') { $plan='starter'; $period='annual'; }
        if ($sku === 'IPV-PRO-Y') { $plan='pro'; $period='annual'; }
        if ($sku === 'IPV-BUSINESS-Y') { $plan='business'; $period='annual'; }

        // Mensili solo se subs presenti (ma qui basta SKU)
        if ($sku === 'IPV-TRIAL-M') { $plan='trial'; $period='monthly'; }
        if ($sku === 'IPV-STARTER-M') { $plan='starter'; $period='monthly'; }
        if ($sku === 'IPV-PRO-M') { $plan='pro'; $period='monthly'; }
        if ($sku === 'IPV-BUSINESS-M') { $plan='business'; $period='monthly'; }

        if (!$plan || !$period) continue;

        // idempotenza
        if ($order->get_meta('_ipv_plan_applied_'.$item_id)) continue;

        // Trova o crea license per utente (qui puoi scegliere: 1 license per utente, o pi√π)
        $license_key = ipv_vendor_get_or_create_license_for_user($user_id);

        ipv_vendor_set_plan($license_key, $user_id, $plan, $period, $order_id);

        $order->update_meta_data('_ipv_plan_applied_'.$item_id, 1);
        $order->update_meta_data('_ipv_license_key', $license_key);
        $order->save();
    }
}
Funzioni helper (concettuali):

ipv_vendor_get_or_create_license_for_user($user_id)

ipv_vendor_set_plan($license_key, $user_id, $plan, $period, $order_id)

Dentro ipv_vendor_set_plan() fai:

update tabella licenses (plan/period/status)

ipv_vendor_grant_monthly_credits() in base al piano

ledger type grant_monthly

10) Golden Prompt (one-time)
Prodotto SKU IPV-GOLDENPROMPT:

in order completed ‚Üí set meta su license:

golden_prompt_enabled = 1

ledger opzionale ‚Äúgrant_feature‚Äù

11) Collegamento ‚Äúcredit/video‚Äù al tuo Vendor API
Ogni endpoint che consuma 1 video deve fare:

available = ipv_vendor_get_available_credits(license_key)

se available < 1 ‚Üí 402/403 ‚Äúcrediti insufficienti‚Äù

altrimenti:

credits_used_month += 1

ledger consume -1 con ref = video_id

12) Output che avrai (esperienza utente finale)
Trial:
si abbona (mensile) ‚Üí ha 5 crediti

va in My Account ‚Üí IPV Credits

compra crediti extra (min 10)

ogni acquisto incrementa credits_extra della sua license

Starter/Pro/Business:
possono comprare annuale anche senza Subscriptions

reset crediti inclusi mensili automatico

extra sempre acquistabili a parte

Se vuoi ‚Äútutto‚Äù davvero come pacchetto unico
Dimmi solo una cosa (senza discussioni lunghe):

1 license per utente (semplice)
oppure
pi√π license per utente (azienda, pi√π siti)?

Io ti ho scritto tutto in modo compatibile con entrambe, ma quella scelta cambia ipv_vendor_get_or_create_license_for_user() e il selector in My Account (gi√† previsto).

Se mi rispondi con una sola parola: ‚Äúsingola‚Äù oppure ‚Äúmultiple‚Äù, ti preparo anche la logica esatta di creazione license e le query pronte.

Hai detto:
1 licenza 1 sito
ChatGPT ha detto:
Perfetto: 1 utente = 1 licenza = 1 sito.
Quindi eliminiamo tutta la complessit√† delle ‚Äúmultiple license‚Äù: My Account mostra una sola license, niente selector, e ogni acquisto (piano/crediti/golden prompt) si aggancia SEMPRE a quella.

Qui sotto ti lascio le funzioni esatte che mancavano + i blocchi da incollare. Con questo hai il sistema completo.

1) Generazione / recupero license (1 per utente)
function ipv_vendor_get_or_create_license_for_user(int $user_id): string {
    global $wpdb;
    $t = $wpdb->prefix.'ipv_licenses';

    $existing = $wpdb->get_var($wpdb->prepare(
        "SELECT license_key FROM {$t} WHERE user_id=%d LIMIT 1",
        $user_id
    ));
    if ($existing) return (string)$existing;

    // genera license key robusta
    $license = strtoupper(wp_generate_password(28, false, false)); // solo alfanumerico
    $license = 'IPV-' . $license;

    $wpdb->insert($t, [
        'license_key'       => $license,
        'user_id'           => $user_id,
        'plan'              => 'trial',
        'status'            => 'active',
        'period'            => 'monthly',
        'credits_monthly'   => 5,
        'credits_extra'     => 0,
        'credits_used_month'=> 0,
        'created_at'        => current_time('mysql'),
        'updated_at'        => current_time('mysql'),
    ]);

    return $license;
}
2) Aggancio ‚Äú1 licenza = 1 sito‚Äù (site_url)
Aggiungi campo tabella site_url (consigliato):

site_url VARCHAR(255) NULL

Quando un sito ‚Äúattiva‚Äù la license (prima chiamata client ‚Üí vendor), fai binding:

function ipv_vendor_bind_site_to_license(string $license_key, string $site_url): bool {
    global $wpdb;
    $t = $wpdb->prefix.'ipv_licenses';

    $site_url = esc_url_raw($site_url);
    if (!$site_url) return false;

    // se gi√† bindato a un altro site -> rifiuta
    $row = $wpdb->get_row($wpdb->prepare("SELECT site_url FROM {$t} WHERE license_key=%s LIMIT 1", $license_key), ARRAY_A);
    if (!$row) return false;

    if (!empty($row['site_url']) && rtrim($row['site_url'],'/') !== rtrim($site_url,'/')) {
        return false; // gi√† legato a un altro sito
    }

    $wpdb->update($t, [
        'site_url' => $site_url,
        'updated_at' => current_time('mysql'),
    ], ['license_key'=>$license_key]);

    return true;
}
Questo garantisce davvero ‚Äú1 licenza 1 sito‚Äù.

3) Impostare piano dopo acquisto (annual o monthly)
function ipv_vendor_set_plan(string $license_key, int $user_id, string $plan, string $period, string $order_id=''): bool {
    global $wpdb;
    $tL = $wpdb->prefix.'ipv_licenses';
    $tG = $wpdb->prefix.'ipv_credit_ledger';

    $monthly = ipv_vendor_plan_monthly_credits($plan);

    // aggiorna piano
    $wpdb->update($tL, [
        'plan'            => $plan,
        'period'          => $period,
        'status'          => 'active',
        'credits_monthly' => $monthly,
        'credits_used_month' => 0,
        'updated_at'      => current_time('mysql'),
    ], ['license_key'=>$license_key]);

    // ledger
    $wpdb->insert($tG, [
        'license_key' => $license_key,
        'user_id'     => $user_id,
        'type'        => 'grant_monthly',
        'amount'      => $monthly,
        'ref_type'    => 'order',
        'ref_id'      => (string)$order_id,
        'note'        => 'Piano impostato: '.$plan.' ('.$period.')',
        'created_at'  => current_time('mysql'),
    ]);

    return true;
}
4) My Account ‚ÄúIPV Credits‚Äù (versione 1-licenza)
Sostituisci il blocco UI con questo: niente selector.

add_action('woocommerce_account_ipv-credits_endpoint', function () {
    if ( ! is_user_logged_in() ) { echo '<p>Devi essere loggato.</p>'; return; }

    $user_id = get_current_user_id();
    $license_key = ipv_vendor_get_or_create_license_for_user($user_id);
    $lic = ipv_vendor_get_license($license_key);

    $available = ipv_vendor_get_available_credits($license_key);

    echo '<h2>IPV Credits</h2>';

    echo '<p><strong>License:</strong> '.esc_html($license_key).'</p>';
    if (!empty($lic['site_url'])) {
        echo '<p><strong>Sito associato:</strong> '.esc_html($lic['site_url']).'</p>';
    }

    echo '<p><strong>Piano:</strong> '.esc_html($lic['plan']).' ('.esc_html($lic['period']).')</p>';
    echo '<p><strong>Crediti disponibili:</strong> '.intval($available).'</p>';
    echo '<p><strong>Crediti mensili inclusi:</strong> '.intval($lic['credits_monthly']).'</p>';
    echo '<p><strong>Crediti extra:</strong> '.intval($lic['credits_extra']).'</p>';

    // CTA crediti extra: passa la license
    $credits_product_id = ipv_vendor_find_product_id_by_sku('IPV-CREDITS-EXTRA');
    if ($credits_product_id) {
        $url = add_query_arg([
            'add-to-cart' => $credits_product_id,
            'ipv_license' => $license_key,
        ], wc_get_cart_url());

        echo '<hr>';
        echo '<h3>Acquista crediti extra</h3>';
        echo '<p>‚Ç¨0,35 per video (minimo 10).</p>';
        echo '<a class="button" href="'.esc_url($url).'">Aggiungi al carrello</a>';
    }
});
5) Crediti extra: obbligo license + minimo 10 + accredito
Qui √® gi√† giusto con 1 licenza: il My Account passa sempre ipv_license valido.

Ricorda solo: idempotenza (gi√† messa) e prezzo fisso 0,35.

6) Wizard prodotti (con regola Trial ‚Äúsolo mensile‚Äù)
Se Subscriptions NON presente:
crea annuali:

Starter 99

Pro 219

Business 439

crea crediti extra (0,35) + golden prompt (se selezionato)

Trial: mostrato disabilitato

Se Subscriptions presente:
crea mensili:

Trial (5 crediti)

Starter 9,99

Pro 19,99

Business 39,99

crea annuali come sopra

crea crediti extra + golden prompt

7) Consumo crediti lato API (1 credito = 1 video)
Quando il client chiama ‚Äúprocess video‚Äù, fai:

function ipv_vendor_consume_credit(string $license_key, string $video_id=''): bool {
    global $wpdb;
    $tL = $wpdb->prefix.'ipv_licenses';
    $tG = $wpdb->prefix.'ipv_credit_ledger';

    $avail = ipv_vendor_get_available_credits($license_key);
    if ($avail < 1) return false;

    $lic = ipv_vendor_get_license($license_key);

    $wpdb->query($wpdb->prepare(
        "UPDATE {$tL} SET credits_used_month = credits_used_month + 1, updated_at=NOW() WHERE license_key=%s",
        $license_key
    ));

    $wpdb->insert($tG, [
        'license_key' => $license_key,
        'user_id'     => (int)$lic['user_id'],
        'type'        => 'consume',
        'amount'      => -1,
        'ref_type'    => 'api',
        'ref_id'      => $video_id,
        'note'        => 'Consumo 1 credito',
        'created_at'  => current_time('mysql'),
    ]);

    return true;
}
Se false ‚Üí rispondi ‚Äúcrediti insufficienti‚Äù.

8) ‚Äú1 licenza 1 sito‚Äù: enforcement in API
Ogni richiesta dal client deve inviare site_url. Al primo uso:

se license non ha site_url ‚Üí bind

se √® diverso ‚Üí blocca

function ipv_vendor_enforce_site(string $license_key, string $site_url): bool {
    $lic = ipv_vendor_get_license($license_key);
    if (!$lic) return false;

    $site_url = rtrim(esc_url_raw($site_url), '/');
    $bound = !empty($lic['site_url']) ? rtrim($lic['site_url'],'/') : '';

    if (!$bound) {
        return ipv_vendor_bind_site_to_license($license_key, $site_url);
    }

    return ($bound === $site_url);
}
Ultimo dettaglio (ma decisivo)
Vuoi che il trial mensile sia:

gratis (0‚Ç¨) oppure

prezzo simbolico (es. 1,99‚Ç¨) per ridurre spam?

Non ti chiedo altro: se non rispondi, lo lascerei 0‚Ç¨ ma con ‚Äú1 sito 1 licenza‚Äù e limiti crediti.

Se vuoi, nel prossimo messaggio ti preparo anche:

i SQL CREATE TABLE pronti

i blocchi per activate hook che crea tabelle

e la pagina admin ‚ÄúLicenze‚Äù (lista + ricerca + ledger).

Hai detto:
1,99
ChatGPT ha detto:
Perfetto: Trial mensile a 1,99 ‚Ç¨ ‚úÖ

Aggiorno quindi la matrice e il wizard cos√¨:

Trial (Monthly)
Prezzo: ‚Ç¨ 1,99 / mese

Crediti inclusi: 5 video / mese

Extra crediti acquistabili: s√¨

SKU: IPV-TRIAL-M

Nel wizard
Se Subscriptions presente ‚Üí crea prodotto subscription:

Nome: IPV ‚Äì Trial (Monthly)

Prezzo ricorrente: 1,99

Periodo: monthly

Meta:

_ipv_vendor_plan = trial

_ipv_vendor_period = monthly

_ipv_vendor_credits_per_month = 5

_ipv_vendor_can_buy_credits = yes

Se Subscriptions NON presente ‚Üí Trial resta disabilitato (non creato).

Nota importante (per evitare ‚Äúdoppi accrediti‚Äù al rinnovo)
Quando arriva un rinnovo mensile del Trial:

NON aggiungere crediti extra

fai solo credits_monthly = 5 e credits_used_month = 0 (come da cron/reset o hook rinnovo)

Se vuoi, posso anche dirti la regola ‚Äúanti abuso‚Äù pi√π pulita per trial:

1 trial per utente (gi√† garantito da ‚Äú1 licenza per utente‚Äù)

1 trial per sito (gi√† garantito da binding site_url alla license)

Hai detto:
si lo voglio questo

i SQL CREATE TABLE pronti

i blocchi per activate hook che crea tabelle

e la pagina admin ‚ÄúLicenze‚Äù (lista + ricerca + ledger).
ChatGPT ha detto:
Ok. Qui sotto hai:

SQL CREATE TABLE (pronto)

Activation hook che crea/aggiorna tabelle con dbDelta()

Pagina admin ‚ÄúLicenze‚Äù con lista + ricerca e ledger (vista dettaglio)

Assumo che il tuo plugin abbia gi√† un core e che tu possa aggiungere questi file in includes/ e admin/. Se vuoi, puoi anche incollare tutto in un unico file, ma meglio modularizzare.

1) SQL CREATE TABLE (pronto)
Usa {$wpdb->prefix} in PHP. Se vuoi l‚ÄôSQL ‚Äúpuro‚Äù da eseguire a mano, sostituisci wp_ con il tuo prefisso.

wp_ipv_licenses
CREATE TABLE `wp_ipv_licenses` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
  `license_key` VARCHAR(64) NOT NULL,
  `user_id` BIGINT UNSIGNED NOT NULL,
  `site_url` VARCHAR(255) NULL,
  `plan` VARCHAR(20) NOT NULL DEFAULT 'trial',
  `status` VARCHAR(20) NOT NULL DEFAULT 'active',
  `period` VARCHAR(20) NOT NULL DEFAULT 'monthly',
  `credits_monthly` INT NOT NULL DEFAULT 0,
  `credits_extra` INT NOT NULL DEFAULT 0,
  `credits_used_month` INT NOT NULL DEFAULT 0,
  `renewal_date` DATETIME NULL,
  `created_at` DATETIME NOT NULL,
  `updated_at` DATETIME NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `license_key` (`license_key`),
  KEY `user_id` (`user_id`),
  KEY `status` (`status`),
  KEY `plan` (`plan`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
wp_ipv_credit_ledger
CREATE TABLE `wp_ipv_credit_ledger` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
  `license_key` VARCHAR(64) NOT NULL,
  `user_id` BIGINT UNSIGNED NOT NULL,
  `type` VARCHAR(32) NOT NULL,
  `amount` INT NOT NULL,
  `ref_type` VARCHAR(32) NOT NULL DEFAULT '',
  `ref_id` VARCHAR(64) NOT NULL DEFAULT '',
  `note` TEXT NULL,
  `created_at` DATETIME NOT NULL,
  PRIMARY KEY (`id`),
  KEY `license_key` (`license_key`),
  KEY `user_id` (`user_id`),
  KEY `type` (`type`),
  KEY `created_at` (`created_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
2) Activation hook (crea tabelle con dbDelta)
Crea includes/class-ipv-vendor-db.php:

<?php
if (!defined('ABSPATH')) exit;

class IPV_Vendor_DB {

    const DB_VERSION = '1.0.0';
    const OPTION_KEY = 'ipv_vendor_db_version';

    public static function install(): void {
        global $wpdb;

        require_once ABSPATH . 'wp-admin/includes/upgrade.php';

        $charset_collate = $wpdb->get_charset_collate();
        $t_licenses = $wpdb->prefix . 'ipv_licenses';
        $t_ledger   = $wpdb->prefix . 'ipv_credit_ledger';

        $sql_licenses = "CREATE TABLE {$t_licenses} (
            id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
            license_key VARCHAR(64) NOT NULL,
            user_id BIGINT UNSIGNED NOT NULL,
            site_url VARCHAR(255) NULL,
            plan VARCHAR(20) NOT NULL DEFAULT 'trial',
            status VARCHAR(20) NOT NULL DEFAULT 'active',
            period VARCHAR(20) NOT NULL DEFAULT 'monthly',
            credits_monthly INT NOT NULL DEFAULT 0,
            credits_extra INT NOT NULL DEFAULT 0,
            credits_used_month INT NOT NULL DEFAULT 0,
            renewal_date DATETIME NULL,
            created_at DATETIME NOT NULL,
            updated_at DATETIME NOT NULL,
            PRIMARY KEY  (id),
            UNIQUE KEY license_key (license_key),
            KEY user_id (user_id),
            KEY status (status),
            KEY plan (plan)
        ) {$charset_collate};";

        $sql_ledger = "CREATE TABLE {$t_ledger} (
            id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
            license_key VARCHAR(64) NOT NULL,
            user_id BIGINT UNSIGNED NOT NULL,
            type VARCHAR(32) NOT NULL,
            amount INT NOT NULL,
            ref_type VARCHAR(32) NOT NULL DEFAULT '',
            ref_id VARCHAR(64) NOT NULL DEFAULT '',
            note TEXT NULL,
            created_at DATETIME NOT NULL,
            PRIMARY KEY  (id),
            KEY license_key (license_key),
            KEY user_id (user_id),
            KEY type (type),
            KEY created_at (created_at)
        ) {$charset_collate};";

        dbDelta($sql_licenses);
        dbDelta($sql_ledger);

        update_option(self::OPTION_KEY, self::DB_VERSION, false);
    }
}
Nel file principale del plugin (es. ipv-pro-vendor.php) aggiungi:

register_activation_hook(__FILE__, function () {
    require_once plugin_dir_path(__FILE__) . 'includes/class-ipv-vendor-db.php';
    IPV_Vendor_DB::install();
});
Se vuoi anche upgrade automatici quando aggiorni DB_VERSION, posso aggiungerlo (ma gi√† cos√¨ √® OK: dbDelta gestisce aggiunte colonne/index).

3) Admin ‚ÄúLicenze‚Äù (lista + ricerca + ledger)
3.1 Menu admin
In includes/class-vendor-core.php (o dove agganci admin menu):

add_action('admin_menu', function(){
    add_menu_page(
        'IPV Licenze',
        'IPV Licenze',
        'manage_options',
        'ipv-licenses',
        'ipv_vendor_render_licenses_page',
        'dashicons-admin-network',
        56
    );
});
3.2 Lista licenze (WP_List_Table)
Crea admin/class-ipv-licenses-table.php:

<?php
if (!defined('ABSPATH')) exit;

if (!class_exists('WP_List_Table')) {
    require_once ABSPATH . 'wp-admin/includes/class-wp-list-table.php';
}

class IPV_Licenses_Table extends WP_List_Table {

    public function get_columns(): array {
        return [
            'license_key' => 'License',
            'user'        => 'Utente',
            'site_url'    => 'Sito',
            'plan'        => 'Piano',
            'period'      => 'Periodo',
            'status'      => 'Stato',
            'credits'     => 'Crediti',
            'updated_at'  => 'Aggiornato',
        ];
    }

    public function prepare_items(): void {
        global $wpdb;
        $table = $wpdb->prefix . 'ipv_licenses';

        $per_page = 20;
        $paged = max(1, (int)($_GET['paged'] ?? 1));

        $search = isset($_GET['s']) ? sanitize_text_field($_GET['s']) : '';
        $where = "WHERE 1=1";
        $args = [];

        if ($search !== '') {
            $where .= " AND (license_key LIKE %s OR site_url LIKE %s OR user_id = %d)";
            $args[] = '%' . $wpdb->esc_like($search) . '%';
            $args[] = '%' . $wpdb->esc_like($search) . '%';
            $args[] = (int)$search;
        }

        $sql_count = "SELECT COUNT(*) FROM {$table} {$where}";
        $total_items = $args ? (int)$wpdb->get_var($wpdb->prepare($sql_count, ...$args)) : (int)$wpdb->get_var($sql_count);

        $offset = ($paged - 1) * $per_page;

        $sql = "SELECT * FROM {$table} {$where} ORDER BY updated_at DESC LIMIT %d OFFSET %d";
        $query_args = $args;
        $query_args[] = $per_page;
        $query_args[] = $offset;

        $rows = $args
            ? $wpdb->get_results($wpdb->prepare($sql, ...$query_args), ARRAY_A)
            : $wpdb->get_results($wpdb->prepare($sql, $per_page, $offset), ARRAY_A);

        $this->items = $rows;

        $this->set_pagination_args([
            'total_items' => $total_items,
            'per_page'    => $per_page,
            'total_pages' => (int)ceil($total_items / $per_page),
        ]);
    }

    protected function column_default($item, $column_name) {
        switch ($column_name) {
            case 'license_key':
                $view_url = add_query_arg([
                    'page' => 'ipv-licenses',
                    'view' => sanitize_text_field($item['license_key']),
                ], admin_url('admin.php'));

                return sprintf(
                    '<strong>%s</strong><br><a href="%s">Vedi ledger</a>',
                    esc_html($item['license_key']),
                    esc_url($view_url)
                );

            case 'user':
                $u = get_user_by('id', (int)$item['user_id']);
                if (!$u) return '#'.$item['user_id'];
                return esc_html($u->user_login) . '<br><small>' . esc_html($u->user_email) . '</small>';

            case 'site_url':
                return $item['site_url'] ? esc_html($item['site_url']) : '<em>‚Äî</em>';

            case 'plan':
            case 'period':
            case 'status':
                return esc_html($item[$column_name]);

            case 'credits':
                $monthly = (int)$item['credits_monthly'];
                $extra   = (int)$item['credits_extra'];
                $used    = (int)$item['credits_used_month'];
                $avail = max(0, ($monthly + $extra) - $used);
                return sprintf(
                    'Disp: <strong>%d</strong><br><small>Monthly: %d ‚Ä¢ Extra: %d ‚Ä¢ Used: %d</small>',
                    $avail, $monthly, $extra, $used
                );

            case 'updated_at':
                return esc_html($item['updated_at']);

            default:
                return '';
        }
    }
}
3.3 Ledger (vista dettaglio license)
Crea admin/class-ipv-ledger-table.php:

<?php
if (!defined('ABSPATH')) exit;

if (!class_exists('WP_List_Table')) {
    require_once ABSPATH . 'wp-admin/includes/class-wp-list-table.php';
}

class IPV_Ledger_Table extends WP_List_Table {
    private string $license_key;

    public function __construct(string $license_key) {
        parent::__construct(['singular' => 'ledger', 'plural' => 'ledger', 'ajax' => false]);
        $this->license_key = $license_key;
    }

    public function get_columns(): array {
        return [
            'created_at' => 'Data',
            'type'       => 'Tipo',
            'amount'     => 'Delta',
            'ref'        => 'Ref',
            'note'       => 'Note',
        ];
    }

    public function prepare_items(): void {
        global $wpdb;
        $t = $wpdb->prefix.'ipv_credit_ledger';

        $per_page = 30;
        $paged = max(1, (int)($_GET['lpaged'] ?? 1));
        $offset = ($paged - 1) * $per_page;

        $total = (int)$wpdb->get_var($wpdb->prepare(
            "SELECT COUNT(*) FROM {$t} WHERE license_key=%s",
            $this->license_key
        ));

        $rows = $wpdb->get_results($wpdb->prepare(
            "SELECT * FROM {$t} WHERE license_key=%s ORDER BY created_at DESC LIMIT %d OFFSET %d",
            $this->license_key, $per_page, $offset
        ), ARRAY_A);

        $this->items = $rows;

        $this->set_pagination_args([
            'total_items' => $total,
            'per_page'    => $per_page,
            'total_pages' => (int)ceil($total / $per_page),
        ]);
    }

    protected function column_default($item, $column_name) {
        switch ($column_name) {
            case 'created_at': return esc_html($item['created_at']);
            case 'type':       return esc_html($item['type']);
            case 'amount':     return ($item['amount'] >= 0 ? '+' : '') . intval($item['amount']);
            case 'ref':
                $ref = trim(($item['ref_type'] ?? '') . ' ' . ($item['ref_id'] ?? ''));
                return $ref ? esc_html($ref) : '‚Äî';
            case 'note':       return $item['note'] ? esc_html($item['note']) : '‚Äî';
            default:           return '';
        }
    }
}
3.4 Render pagina admin (lista + dettaglio)
Crea admin/pages/licenses-page.php:

<?php
if (!defined('ABSPATH')) exit;

function ipv_vendor_render_licenses_page() {
    echo '<div class="wrap">';
    echo '<h1>IPV Licenze</h1>';

    $view = isset($_GET['view']) ? sanitize_text_field($_GET['view']) : '';

    if ($view) {
        require_once plugin_dir_path(__FILE__) . '../class-ipv-ledger-table.php';
        global $wpdb;
        $tL = $wpdb->prefix.'ipv_licenses';

        $lic = $wpdb->get_row($wpdb->prepare("SELECT * FROM {$tL} WHERE license_key=%s LIMIT 1", $view), ARRAY_A);

        $back_url = esc_url(admin_url('admin.php?page=ipv-licenses'));

        if (!$lic) {
            echo '<p><a class="button" href="'.$back_url.'">‚Üê Torna</a></p>';
            echo '<div class="notice notice-error"><p>License non trovata.</p></div>';
            echo '</div>';
            return;
        }

        echo '<p><a class="button" href="'.$back_url.'">‚Üê Torna</a></p>';

        echo '<h2>Dettaglio: <code>'.esc_html($lic['license_key']).'</code></h2>';
        echo '<table class="widefat striped" style="max-width: 980px;">';
        echo '<tbody>';
        echo '<tr><th>Utente</th><td>#'.intval($lic['user_id']).'</td></tr>';
        echo '<tr><th>Sito</th><td>'.($lic['site_url'] ? esc_html($lic['site_url']) : '‚Äî').'</td></tr>';
        echo '<tr><th>Piano</th><td>'.esc_html($lic['plan']).' ('.esc_html($lic['period']).')</td></tr>';
        echo '<tr><th>Stato</th><td>'.esc_html($lic['status']).'</td></tr>';
        echo '<tr><th>Crediti</th><td>Monthly: '.intval($lic['credits_monthly']).' ‚Ä¢ Extra: '.intval($lic['credits_extra']).' ‚Ä¢ Used: '.intval($lic['credits_used_month']).'</td></tr>';
        echo '<tr><th>Aggiornato</th><td>'.esc_html($lic['updated_at']).'</td></tr>';
        echo '</tbody></table>';

        echo '<h2 style="margin-top:18px;">Ledger crediti</h2>';
        $ledger = new IPV_Ledger_Table($view);
        $ledger->prepare_items();
        $ledger->display();

        echo '</div>';
        return;
    }

    require_once plugin_dir_path(__FILE__) . '../class-ipv-licenses-table.php';

    $table = new IPV_Licenses_Table();
    $table->prepare_items();

    echo '<form method="get">';
    echo '<input type="hidden" name="page" value="ipv-licenses" />';
    $table->search_box('Cerca license/sito/user_id', 'ipv-licenses-search');
    $table->display();
    echo '</form>';

    echo '</div>';
}
3.5 Includi la pagina nel plugin
Nel tuo file principale o in un loader admin:

if (is_admin()) {
    require_once plugin_dir_path(__FILE__) . 'admin/pages/licenses-page.php';
}
Extra (consigliato ma opzionale)
Se vuoi rendere ‚ÄúLicenze‚Äù visibile anche a Shop Manager, cambia capability del menu da manage_options a manage_woocommerce.

Se vuoi, nel prossimo step ti aggiungo anche:

pulsanti in admin per ‚ÄúAggiungi crediti manualmente‚Äù e ‚ÄúReset monthly ora‚Äù (con nonce e ledger)

pagina ‚ÄúOrdini ‚Üí License‚Äù (metabox) per vedere la license agganciata all‚Äôordine

export CSV licenze + ledger

Dimmi solo: vuoi che l‚Äôadmin possa modificare piano/stato dalla lista (quick actions) o preferisci solo lettura?

Hai detto:
pulsanti in admin per ‚ÄúAggiungi crediti manualmente‚Äù e ‚ÄúReset monthly ora‚Äù (con nonce e ledger)

pagina ‚ÄúOrdini ‚Üí License‚Äù (metabox) per vedere la license agganciata all‚Äôordine

export CSV licenze + ledger
ChatGPT ha detto:
Ok ‚úÖ qui hai tutto ci√≤ che hai chiesto, pronto da incollare:

Pulsanti admin: Aggiungi crediti manualmente + Reset monthly ora (con nonce + ledger)

Metabox in Ordini per vedere License agganciata all‚Äôordine

Export CSV: licenze + ledger (filtrabile per license)

Presumo che tu abbia gi√† le funzioni DB che abbiamo definito (ipv_vendor_get_license, ipv_vendor_add_credits, ipv_vendor_grant_monthly_credits, ipv_vendor_plan_monthly_credits, ecc.). Qui aggiungo solo UI + handler.

1) Pulsanti admin (nonce + ledger)
1.1 Aggiungi i form nella pagina dettaglio License
Nel file admin/pages/licenses-page.php, dentro la view dettaglio (dopo la tabella ‚ÄúDettaglio‚Äù), incolla:

$license_key = $lic['license_key'];
$nonce_add   = wp_create_nonce('ipv_add_credits_'.$license_key);
$nonce_reset = wp_create_nonce('ipv_reset_monthly_'.$license_key);

echo '<hr style="margin:18px 0;">';
echo '<h2>Azioni</h2>';

echo '<h3>Aggiungi crediti manualmente</h3>';
echo '<form method="post" action="'.esc_url(admin_url('admin-post.php')).'" style="max-width:420px;">';
echo '<input type="hidden" name="action" value="ipv_add_credits_admin">';
echo '<input type="hidden" name="license_key" value="'.esc_attr($license_key).'">';
echo '<input type="hidden" name="_wpnonce" value="'.esc_attr($nonce_add).'">';
echo '<p><label>Crediti da aggiungere</label><br>';
echo '<input type="number" name="amount" min="1" step="1" required style="width:120px;"></p>';
echo '<p><label>Nota (opzionale)</label><br>';
echo '<input type="text" name="note" placeholder="es. compensazione / bonus" style="width:100%;"></p>';
echo '<p><button class="button button-primary">Aggiungi crediti</button></p>';
echo '</form>';

echo '<h3>Reset monthly ora</h3>';
echo '<form method="post" action="'.esc_url(admin_url('admin-post.php')).'" onsubmit="return confirm(\'Confermi reset crediti mensili?\');">';
echo '<input type="hidden" name="action" value="ipv_reset_monthly_admin">';
echo '<input type="hidden" name="license_key" value="'.esc_attr($license_key).'">';
echo '<input type="hidden" name="_wpnonce" value="'.esc_attr($nonce_reset).'">';
echo '<p><button class="button">Reset monthly adesso</button></p>';
echo '</form>';
1.2 Handler admin-post (sicuro + capability + redirect)
Crea admin/class-ipv-admin-actions.php:

<?php
if (!defined('ABSPATH')) exit;

class IPV_Vendor_Admin_Actions {

    public static function init(): void {
        add_action('admin_post_ipv_add_credits_admin',  [__CLASS__, 'handle_add_credits']);
        add_action('admin_post_ipv_reset_monthly_admin', [__CLASS__, 'handle_reset_monthly']);
    }

    public static function handle_add_credits(): void {
        if (!current_user_can('manage_options')) wp_die('Unauthorized');

        $license_key = isset($_POST['license_key']) ? sanitize_text_field($_POST['license_key']) : '';
        if (!$license_key) wp_die('Missing license');

        check_admin_referer('ipv_add_credits_'.$license_key);

        $amount = isset($_POST['amount']) ? (int)$_POST['amount'] : 0;
        $note   = isset($_POST['note']) ? sanitize_text_field($_POST['note']) : '';

        if ($amount < 1) {
            self::redirect($license_key, 'amount_invalid');
        }

        // Accredita EXTRA + ledger (gi√† fa ledger)
        ipv_vendor_add_credits($license_key, $amount, 'admin', get_current_user_id(), $note ?: 'Aggiunta manuale admin');

        self::redirect($license_key, 'credits_added');
    }

    public static function handle_reset_monthly(): void {
        if (!current_user_can('manage_options')) wp_die('Unauthorized');

        $license_key = isset($_POST['license_key']) ? sanitize_text_field($_POST['license_key']) : '';
        if (!$license_key) wp_die('Missing license');

        check_admin_referer('ipv_reset_monthly_'.$license_key);

        $lic = ipv_vendor_get_license($license_key);
        if (!$lic) self::redirect($license_key, 'license_not_found');

        $monthly = ipv_vendor_plan_monthly_credits($lic['plan']);
        ipv_vendor_grant_monthly_credits($license_key, $monthly, 'admin_reset');

        self::redirect($license_key, 'monthly_reset');
    }

    private static function redirect(string $license_key, string $msg): void {
        $url = add_query_arg([
            'page' => 'ipv-licenses',
            'view' => $license_key,
            'msg'  => $msg,
        ], admin_url('admin.php'));

        wp_safe_redirect($url);
        exit;
    }
}
Poi inizializzalo (in admin loader):

if (is_admin()) {
    require_once plugin_dir_path(__FILE__) . 'admin/class-ipv-admin-actions.php';
    IPV_Vendor_Admin_Actions::init();
}
1.3 Messaggi admin (opzionale ma comodo)
Nel render dettaglio license, prima dei form:

if (isset($_GET['msg'])) {
    $m = sanitize_text_field($_GET['msg']);
    $map = [
        'credits_added'   => 'Crediti aggiunti con successo.',
        'monthly_reset'   => 'Reset monthly eseguito.',
        'amount_invalid'  => 'Importo non valido.',
        'license_not_found'=> 'License non trovata.',
    ];
    if (isset($map[$m])) {
        echo '<div class="notice notice-success"><p>'.esc_html($map[$m]).'</p></div>';
    }
}
2) Metabox ‚ÄúOrdini ‚Üí License‚Äù
Mostra la license agganciata all‚Äôordine (da _ipv_license_key che setti quando applichi piano oppure quando acquisti crediti).

Crea admin/class-ipv-order-metabox.php:

<?php
if (!defined('ABSPATH')) exit;

class IPV_Vendor_Order_Metabox {

    public static function init(): void {
        add_action('add_meta_boxes', [__CLASS__, 'add_box']);
    }

    public static function add_box(): void {
        // WooCommerce Orders (HPOS e non)
        $screens = ['shop_order', 'woocommerce_page_wc-orders'];
        foreach ($screens as $screen) {
            add_meta_box(
                'ipv_vendor_license_box',
                'IPV License',
                [__CLASS__, 'render'],
                $screen,
                'side',
                'default'
            );
        }
    }

    public static function render($post_or_order): void {
        $order_id = is_object($post_or_order) && isset($post_or_order->ID) ? (int)$post_or_order->ID : 0;

        // HPOS compat
        if (class_exists('\Automattic\WooCommerce\Utilities\OrderUtil') && method_exists('\Automattic\WooCommerce\Utilities\OrderUtil','custom_orders_table_usage_is_enabled')) {
            if (\Automattic\WooCommerce\Utilities\OrderUtil::custom_orders_table_usage_is_enabled() && is_object($post_or_order) && method_exists($post_or_order, 'get_id')) {
                $order_id = (int)$post_or_order->get_id();
            }
        }

        $order = wc_get_order($order_id);
        if (!$order) { echo '<p>Ordine non trovato.</p>'; return; }

        $license = $order->get_meta('_ipv_license_key');

        // fallback: cerca in order items (per crediti extra)
        if (!$license) {
            foreach ($order->get_items() as $item) {
                $lk = $item->get_meta('ipv_license');
                if ($lk) { $license = $lk; break; }
            }
        }

        if (!$license) {
            echo '<p><em>Nessuna license associata.</em></p>';
            return;
        }

        echo '<p><strong>License:</strong><br><code>'.esc_html($license).'</code></p>';

        $view_url = add_query_arg(['page'=>'ipv-licenses','view'=>$license], admin_url('admin.php'));
        echo '<p><a class="button button-small" href="'.esc_url($view_url).'">Apri licenza</a></p>';
    }
}
Init in admin loader:

if (is_admin()) {
    require_once plugin_dir_path(__FILE__) . 'admin/class-ipv-order-metabox.php';
    IPV_Vendor_Order_Metabox::init();
}
3) Export CSV Licenze + Ledger
Aggiungo 2 azioni:

Export Licenze CSV

Export Ledger CSV (se sei nel dettaglio di una license)

3.1 Pulsanti UI
Nella pagina lista licenze (ipv_vendor_render_licenses_page() quando NON c‚Äô√® view) sopra la tabella:

$export_url = wp_nonce_url(
    add_query_arg(['page'=>'ipv-licenses','ipv_export'=>'licenses'], admin_url('admin.php')),
    'ipv_export_licenses'
);
echo '<p><a class="button" href="'.esc_url($export_url).'">Export Licenze CSV</a></p>';
Nel dettaglio license (quando view esiste), sopra il ledger:

$export_ledger_url = wp_nonce_url(
    add_query_arg(['page'=>'ipv-licenses','view'=>$view,'ipv_export'=>'ledger'], admin_url('admin.php')),
    'ipv_export_ledger_'.$view
);
echo '<p><a class="button" href="'.esc_url($export_ledger_url).'">Export Ledger CSV</a></p>';
3.2 Handler export (admin_init)
Crea admin/class-ipv-export.php:

<?php
if (!defined('ABSPATH')) exit;

class IPV_Vendor_Export {

    public static function init(): void {
        add_action('admin_init', [__CLASS__, 'maybe_export']);
    }

    public static function maybe_export(): void {
        if (!is_admin() || !current_user_can('manage_options')) return;
        if (!isset($_GET['page']) || $_GET['page'] !== 'ipv-licenses') return;
        if (empty($_GET['ipv_export'])) return;

        $type = sanitize_text_field($_GET['ipv_export']);

        if ($type === 'licenses') {
            check_admin_referer('ipv_export_licenses');
            self::export_licenses();
        }

        if ($type === 'ledger') {
            $license = isset($_GET['view']) ? sanitize_text_field($_GET['view']) : '';
            if (!$license) wp_die('Missing license');
            check_admin_referer('ipv_export_ledger_'.$license);
            self::export_ledger($license);
        }
    }

    private static function export_licenses(): void {
        global $wpdb;
        $t = $wpdb->prefix.'ipv_licenses';

        $rows = $wpdb->get_results("SELECT * FROM {$t} ORDER BY updated_at DESC", ARRAY_A);

        self::send_csv_headers('ipv-licenses.csv');

        $out = fopen('php://output', 'w');
        fputcsv($out, ['license_key','user_id','site_url','plan','period','status','credits_monthly','credits_extra','credits_used_month','renewal_date','created_at','updated_at']);

        foreach ($rows as $r) {
            fputcsv($out, [
                $r['license_key'],
                $r['user_id'],
                $r['site_url'],
                $r['plan'],
                $r['period'],
                $r['status'],
                $r['credits_monthly'],
                $r['credits_extra'],
                $r['credits_used_month'],
                $r['renewal_date'],
                $r['created_at'],
                $r['updated_at'],
            ]);
        }

        fclose($out);
        exit;
    }

    private static function export_ledger(string $license_key): void {
        global $wpdb;
        $t = $wpdb->prefix.'ipv_credit_ledger';

        $rows = $wpdb->get_results($wpdb->prepare(
            "SELECT * FROM {$t} WHERE license_key=%s ORDER BY created_at DESC",
            $license_key
        ), ARRAY_A);

        self::send_csv_headers('ipv-ledger-'.$license_key.'.csv');

        $out = fopen('php://output', 'w');
        fputcsv($out, ['license_key','user_id','type','amount','ref_type','ref_id','note','created_at']);

        foreach ($rows as $r) {
            fputcsv($out, [
                $r['license_key'],
                $r['user_id'],
                $r['type'],
                $r['amount'],
                $r['ref_type'],
                $r['ref_id'],
                $r['note'],
                $r['created_at'],
            ]);
        }

        fclose($out);
        exit;
    }

    private static function send_csv_headers(string $filename): void {
        nocache_headers();
        header('Content-Type: text/csv; charset=utf-8');
        header('Content-Disposition: attachment; filename="'.$filename.'"');
    }
}
Init in admin loader:

if (is_admin()) {
    require_once plugin_dir_path(__FILE__) . 'admin/class-ipv-export.php';
    IPV_Vendor_Export::init();
}
Nota pratica (capability)
Io ho messo manage_options. Se vuoi che anche Shop Manager possa farlo:

sostituisci con manage_woocommerce.

Se vuoi, prossimo micro-step (utilissimo): ti aggiungo una colonna ‚ÄúSite lock‚Äù nella lista (verde/rosso) e un pulsante ‚ÄúSblocca sito‚Äù (solo admin, con nonce) per gestire migrazioni controllate quando un cliente cambia dominio.

Hai detto:
ovviamente anche gli altri piani possono acquistare video/crediti

si aggiungi le ultime cose
ChatGPT ha detto:
Perfetto ‚úÖ: tutti i piani (Trial/Starter/Pro/Business) possono acquistare crediti extra. Lo consideriamo ‚Äúsempre attivo‚Äù.

Ora aggiungo le ‚Äúultime cose‚Äù che ti avevo proposto, fatte bene:

Colonna Site lock (verde/rosso) nella lista licenze

Pulsante Sblocca sito (nonce + ledger) nella view dettaglio

Pulsante Imposta/Rebind sito (opzionale, sempre con nonce) per migrazioni controllate

Regola: crediti extra acquistabili sempre (gi√† OK, ma aggiungo anche un check che non blocca nessun piano)

1) Site lock: colonna nella lista licenze
Nel file admin/class-ipv-licenses-table.php aggiungi la colonna in get_columns():

'site_lock'   => 'Site lock',
Quindi il blocco completo (aggiunta dove vuoi) diventa:

return [
  'license_key' => 'License',
  'user'        => 'Utente',
  'site_lock'   => 'Site lock',
  'site_url'    => 'Sito',
  'plan'        => 'Piano',
  'period'      => 'Periodo',
  'status'      => 'Stato',
  'credits'     => 'Crediti',
  'updated_at'  => 'Aggiornato',
];
Poi in column_default() aggiungi:

case 'site_lock':
    $locked = !empty($item['site_url']);
    if ($locked) {
        return '<span style="display:inline-block;padding:2px 8px;border-radius:12px;background:#d1e7dd;color:#0f5132;font-weight:600;">LOCK</span>';
    }
    return '<span style="display:inline-block;padding:2px 8px;border-radius:12px;background:#f8d7da;color:#842029;font-weight:600;">UNLOCK</span>';
2) Pulsanti ‚ÄúSblocca sito‚Äù + ‚ÄúRebind sito‚Äù nel dettaglio license
Nel file admin/pages/licenses-page.php, nella view dettaglio (dove hai gi√† ‚ÄúAzioni‚Äù), aggiungi dopo Reset Monthly:

$nonce_unlock = wp_create_nonce('ipv_unlock_site_'.$license_key);
$nonce_rebind = wp_create_nonce('ipv_rebind_site_'.$license_key);

echo '<h3>Site lock</h3>';

echo '<form method="post" action="'.esc_url(admin_url('admin-post.php')).'" onsubmit="return confirm(\'Sbloccare il sito associato? La license potr√† essere riassociata al primo sito che si connette.\');">';
echo '<input type="hidden" name="action" value="ipv_unlock_site_admin">';
echo '<input type="hidden" name="license_key" value="'.esc_attr($license_key).'">';
echo '<input type="hidden" name="_wpnonce" value="'.esc_attr($nonce_unlock).'">';
echo '<p><button class="button">Sblocca sito</button></p>';
echo '</form>';

echo '<form method="post" action="'.esc_url(admin_url('admin-post.php')).'" style="max-width:520px;">';
echo '<input type="hidden" name="action" value="ipv_rebind_site_admin">';
echo '<input type="hidden" name="license_key" value="'.esc_attr($license_key).'">';
echo '<input type="hidden" name="_wpnonce" value="'.esc_attr($nonce_rebind).'">';
echo '<p><label>Imposta/Rebind sito (URL completo)</label><br>';
echo '<input type="url" name="site_url" placeholder="https://esempio.com" style="width:100%;" required></p>';
echo '<p><button class="button">Imposta sito</button></p>';
echo '<p><small>Usa questa funzione solo per migrazioni controllate (cambio dominio/hosting).</small></p>';
echo '</form>';
3) Handler admin-post per unlock/rebind (nonce + ledger)
Nel file admin/class-ipv-admin-actions.php aggiungi gli hook dentro init():

add_action('admin_post_ipv_unlock_site_admin', [__CLASS__, 'handle_unlock_site']);
add_action('admin_post_ipv_rebind_site_admin', [__CLASS__, 'handle_rebind_site']);
Poi aggiungi le funzioni:

public static function handle_unlock_site(): void {
    if (!current_user_can('manage_options')) wp_die('Unauthorized');

    $license_key = isset($_POST['license_key']) ? sanitize_text_field($_POST['license_key']) : '';
    if (!$license_key) wp_die('Missing license');

    check_admin_referer('ipv_unlock_site_'.$license_key);

    global $wpdb;
    $tL = $wpdb->prefix.'ipv_licenses';
    $tG = $wpdb->prefix.'ipv_credit_ledger';

    $lic = ipv_vendor_get_license($license_key);
    if (!$lic) self::redirect($license_key, 'license_not_found');

    // unlock: svuota site_url
    $wpdb->update($tL, [
        'site_url'   => null,
        'updated_at' => current_time('mysql'),
    ], ['license_key'=>$license_key]);

    // ledger event (type adjust, amount 0)
    $wpdb->insert($tG, [
        'license_key' => $license_key,
        'user_id'     => (int)$lic['user_id'],
        'type'        => 'adjust',
        'amount'      => 0,
        'ref_type'    => 'admin',
        'ref_id'      => (string)get_current_user_id(),
        'note'        => 'Sblocco sito (site_url cleared)',
        'created_at'  => current_time('mysql'),
    ]);

    self::redirect($license_key, 'site_unlocked');
}

public static function handle_rebind_site(): void {
    if (!current_user_can('manage_options')) wp_die('Unauthorized');

    $license_key = isset($_POST['license_key']) ? sanitize_text_field($_POST['license_key']) : '';
    if (!$license_key) wp_die('Missing license');

    check_admin_referer('ipv_rebind_site_'.$license_key);

    $site_url = isset($_POST['site_url']) ? esc_url_raw($_POST['site_url']) : '';
    $site_url = $site_url ? rtrim($site_url,'/') : '';

    if (!$site_url) self::redirect($license_key, 'site_invalid');

    global $wpdb;
    $tL = $wpdb->prefix.'ipv_licenses';
    $tG = $wpdb->prefix.'ipv_credit_ledger';

    $lic = ipv_vendor_get_license($license_key);
    if (!$lic) self::redirect($license_key, 'license_not_found');

    $wpdb->update($tL, [
        'site_url'   => $site_url,
        'updated_at' => current_time('mysql'),
    ], ['license_key'=>$license_key]);

    $wpdb->insert($tG, [
        'license_key' => $license_key,
        'user_id'     => (int)$lic['user_id'],
        'type'        => 'adjust',
        'amount'      => 0,
        'ref_type'    => 'admin',
        'ref_id'      => (string)get_current_user_id(),
        'note'        => 'Rebind sito a: '.$site_url,
        'created_at'  => current_time('mysql'),
    ]);

    self::redirect($license_key, 'site_rebound');
}
Aggiorna anche la mappa messaggi (dove avevi credits_added, ecc.):

'site_unlocked' => 'Sito sbloccato. La license potr√† essere associata al prossimo sito che si connette.',
'site_rebound'  => 'Sito impostato correttamente.',
'site_invalid'  => 'URL sito non valido.',
4) Crediti extra acquistabili da tutti i piani (gi√† OK)
Con ‚Äú1 licenza per utente‚Äù:

il pulsante ‚ÄúAcquista crediti extra‚Äù in My Account √® sempre visibile

e non c‚Äô√® nessun blocco per piano

Se vuoi una ‚Äúcintura di sicurezza‚Äù lato server (API), metti solo:

license active

site_url match

5) Enforcement ‚Äú1 licenza = 1 sito‚Äù con migrazione controllata
La regola diventa:

di default: se site_url √® valorizzato ‚Üí solo quel sito

per migrazione:

admin clicca Sblocca sito

il nuovo sito al primo handshake si lega automaticamente

In alternativa:

admin usa ‚ÄúImposta sito‚Äù e lo vincola subito.

Se vuoi, ultimo upgrade che ti consiglio (ma lo faccio solo se me lo chiedi): cooldown migrazione (es. max 1 unlock ogni 7 giorni per license) per evitare abusi.

Hai detto:
e che abusi ci potrebbero essere?
ChatGPT ha detto:
Se la license √® ‚Äú1 licenza = 1 sito‚Äù, l‚Äôunico punto davvero ‚Äúattaccabile‚Äù √® proprio la migrazione/sblocco del sito. Gli abusi tipici (reali) sono questi:

1) Condivisione della licenza tra pi√π siti (turnazione)
Un cliente pu√≤ usare la licenza su sito A, poi chiede ‚Äúmigrazione‚Äù e la usa su sito B, poi di nuovo su A, ecc.
Se lo sblocco √® facile/illimitato, di fatto diventa 1 licenza = N siti (a rotazione).

2) Rivendita/affitto della licenza
Se pu√≤ ‚Äúspostarla‚Äù spesso, pu√≤ prestare la chiave ad altri: oggi la usa un‚Äôagenzia, domani un altro cliente.

3) Bypass dei limiti ‚Äúper sito‚Äù su crediti/uso
Se il consumo crediti √® legato alla license, spostandola pu√≤ distribuire l‚Äôuso su pi√π installazioni (anche se i crediti restano gli stessi, il problema √® la violazione del vincolo commerciale).

4) Support burden / caos operativo
Non √® un ‚Äúhack‚Äù, ma √® abuso pratico: se uno pu√≤ cambiare dominio ogni giorno ti riempie di ticket ‚Äúnon va la licenza‚Äù, perch√© il binding salta continuamente.

5) Frodi su rimborsi / chargeback (scenario raro ma esiste)
Compra, attiva sul sito A, usa i crediti, chiede rimborso/chargeback, poi tenta di riattivare su un altro sito con sblocco frequente.
Il ledger ti aiuta a dimostrarlo, ma prevenire √® meglio.

Perch√© il cooldown √® utile (ma non obbligatorio)
Non serve per ‚Äúsicurezza informatica‚Äù, serve per far rispettare la regola commerciale 1 licenza = 1 sito senza trasformarla in ‚Äú1 licenza = infiniti siti a staffetta‚Äù.

Regola pratica consigliata
1 sblocco gratuito ogni 30 giorni (o 7 giorni se vuoi essere pi√π permissivo)

In alternativa: sblocco sempre possibile ma solo da admin, e tracciato (gi√† lo facciamo), senza automatismi.

Se vuoi il compromesso perfetto (zero frizione, zero abusi)
Rebind manuale da admin (come abbiamo fatto)

Unlock solo se:

l‚Äôordine/subscription √® attivo

non hai gi√† sbloccato negli ultimi X giorni

log su ledger ‚Äúsite unlock‚Äù

Se mi dici ‚Äú7 giorni‚Äù o ‚Äú30 giorni‚Äù, ti do il blocco di codice esatto (2 funzioni) da incollare nel tuo handler handle_unlock_site() per imporre il cooldown con messaggio chiaro in admin.

Hai detto:
ok aggiungilo
ChatGPT ha detto:
Ok ‚úÖ aggiungo il cooldown sullo sblocco sito in modo pulito e tracciabile.

Obiettivo
Sblocca sito possibile solo 1 volta ogni 30 giorni per license (default)

Override facile (se vuoi 7 giorni): basta cambiare una costante o filtro

Tracciamento: salvo site_unlock_at in tabella + ledger

1) DB: aggiungi colonna site_unlock_at
Modifica SQL (tabella licenze)
Aggiungi questa colonna:

ALTER TABLE `wp_ipv_licenses`
ADD COLUMN `site_unlock_at` DATETIME NULL AFTER `site_url`;
Se usi dbDelta() (consigliato)
Nel tuo includes/class-ipv-vendor-db.php (dove hai CREATE TABLE {$t_licenses} (...)) aggiungi:

site_unlock_at DATETIME NULL,
Subito dopo site_url VARCHAR(255) NULL, va benissimo.

Poi incrementa DB_VERSION (es. 1.0.1) cos√¨ sai che √® passato.

2) Helper: cooldown days (configurabile)
Metti in un file di util (o in admin-actions):

function ipv_vendor_site_unlock_cooldown_days(): int {
    $days = 30; // default
    return max(0, (int) apply_filters('ipv_vendor_site_unlock_cooldown_days', $days));
}
Se un giorno vuoi 7 giorni, ti basta:

add_filter('ipv_vendor_site_unlock_cooldown_days', fn() => 7);
3) Admin action: blocca unlock se dentro cooldown
Nel file admin/class-ipv-admin-actions.php, dentro handle_unlock_site() prima di fare l‚Äôupdate site_url = null, inserisci questo blocco:

$cooldown_days = ipv_vendor_site_unlock_cooldown_days();

if ($cooldown_days > 0 && !empty($lic['site_unlock_at'])) {
    $last = strtotime($lic['site_unlock_at']);
    if ($last) {
        $next_allowed = $last + ($cooldown_days * DAY_IN_SECONDS);
        if (time() < $next_allowed) {
            // calcola giorni rimanenti (arrotonda in su)
            $remaining = (int) ceil(($next_allowed - time()) / DAY_IN_SECONDS);

            // redirect con msg + remaining
            $url = add_query_arg([
                'page' => 'ipv-licenses',
                'view' => $license_key,
                'msg'  => 'unlock_cooldown',
                'rem'  => $remaining,
            ], admin_url('admin.php'));

            wp_safe_redirect($url);
            exit;
        }
    }
}
Poi quando fai davvero l‚Äôunlock, aggiorna anche site_unlock_at:

$wpdb->update($tL, [
    'site_url'       => null,
    'site_unlock_at' => current_time('mysql'),
    'updated_at'     => current_time('mysql'),
], ['license_key'=>$license_key]);
E nel ledger (quello che gi√† inserisci) lascia la nota ‚ÄúSblocco sito‚Ä¶‚Äù.

4) Messaggio admin ‚Äúcooldown attivo‚Äù
Nel mapping messaggi (dove avevi site_unlocked, ecc.) aggiungi:

'unlock_cooldown' => 'Sblocco negato: cooldown attivo.',
E nel render, se vuoi mostrare i giorni residui:

if (isset($_GET['msg']) && $_GET['msg'] === 'unlock_cooldown') {
    $rem = isset($_GET['rem']) ? (int)$_GET['rem'] : 0;
    echo '<div class="notice notice-warning"><p>';
    echo 'Sblocco non disponibile. Riprova tra <strong>'.max(1,$rem).'</strong> giorno/i.';
    echo '</p></div>';
}
5) Cosa succede lato pratica (flusso migrazione)
Admin clicca Sblocca sito

per 30 giorni non pu√≤ farlo di nuovo

il nuovo sito si ‚Äúlega‚Äù al primo handshake (oppure fai ‚ÄúImposta sito‚Äù manuale, che NON dovrebbe avere cooldown: √® un‚Äôazione controllata)

Se vuoi anche mettere cooldown su ‚ÄúImposta sito‚Äù, dimmelo e lo aggiungo (io lo lascerei sempre disponibile per emergenze reali).

Vuoi che il cooldown sia 30 giorni (come sopra) o preferisci 7 giorni? (se non mi rispondi, resta 30).

Hai detto:
7 giorni
ChatGPT ha detto:
Perfetto ‚úÖ imposto cooldown 7 giorni.

Hai 2 modi, scegli quello pi√π comodo (io ti consiglio il #1 cos√¨ non tocchi altro):

1) Override via filtro (consigliato)
Metti questo nel plugin (es. nel file principale o in un loader includes/hooks.php):

add_filter('ipv_vendor_site_unlock_cooldown_days', function($days){
    return 7;
});
Fine. Tutto il resto resta invariato.

2) Hardcode diretto
Nella funzione:

function ipv_vendor_site_unlock_cooldown_days(): int {
    return 7;
}
Nota
Il cooldown si applica solo a ‚ÄúSblocca sito‚Äù (unlock).

‚ÄúImposta/Rebind sito‚Äù resta sempre possibile per emergenze/migrazioni controllate (come √® giusto).

Se vuoi, posso anche aggiungere nel dettaglio licenza una riga tipo:
‚ÄúUltimo sblocco: data‚Ä¶ / prossimo sblocco possibile: data‚Ä¶‚Äù cos√¨ lo vedi subito in admin.

Hai detto:
si fai poi fammi zip
ChatGPT ha detto:

Ragionamento interrotto
Network connection lost. Attempting to reconnect‚Ä¶

Network connection lost. Attempting to reconnect‚Ä¶


Nessun file selezionatoNessun file selezionato
ChatGPT pu√≤ commettere errori. Assicurati di verificare le informazioni importanti. Vedi Preferenze sui cookie.
Attivit√†
¬∑
22m 39s

Ragionamento
Preparando il nuovo plugin e aggiornamento della versione
Dobbiamo creare una nuova versione del plugin con alcune modifiche, come azioni admin, tabelle DB, endpoint "my account", wizard, e prodotti. Il tutto con l'aggiunta della gestione del cooldown di 7 giorni. User√≤ il sistema di gestione dei file per modificare e aggiornare il pacchetto, mantenendo la struttura esistente.

Aggiornamento della pagina dei dettagli e azioni metabox
Devo aggiorare la pagina dei dettagli per mostrare l'ultimo sblocco e il prossimo consentito. Inoltre, implementer√≤ l'azione di esportazione e metabox. Assicurer√≤ che non ci siano errori fatali dovuti a classi mancanti e utilizzer√≤ la lista di inclusioni dell'autoloader nel file principale del plugin.

Creando e modificando pacchetto plugin zip
import zipfile, os, re, textwrap, json, shutil, pathlib, datetime, math
zip_path="/mnt/data/ipv-pro-vendor-server-v1.4.0-optimized-autoinstaller-FIXED2-legacy-alias.zip"
os.path.exists(zip_path), zip_path

Verificando esistenza del file zip
import os, zipfile, shutil, re, textwrap, pathlib, datetime, math, json
zip_path="/mnt/data/ipv-pro-vendor-server-v1.4.0-optimized-autoinstaller-FIXED2-legacy-alias.zip"
os.path.exists(zip_path), zip_path

(True,
 '/mnt/data/ipv-pro-vendor-server-v1.4.0-optimized-autoinstaller-FIXED2-legacy-alias.zip')
Estrazione file in una directory temporanea
Ho deciso di estrarre i file in una directory temporanea per evitare conflitti o sovrascritture nei percorsi principali. In questo modo, posso lavorare sui file senza compromettere il resto del sistema o applicazione. √à un buon approccio per garantire ordine e sicurezza durante le modifiche.

Estraendo file ZIP in directory temporanea
import tempfile, os, zipfile, pathlib, shutil, re, textwrap
tmpdir=tempfile.mkdtemp()
with zipfile.ZipFile(zip_path,'r') as z:
    z.extractall(tmpdir)
tmpdir, os.listdir(tmpdir)[:5]

('/tmp/tmpcf8h9xg3', ['ipv-pro-vendor-optimized'])
Elenco della cartella del plugin
Ho bisogno di visualizzare il contenuto della cartella del plugin per avere una panoramica completa dei file e capire meglio come organizzare le modifiche necessarie. Questo mi aiuter√† a capire la struttura e monitorare eventuali errori o conflitti nei file esistenti prima di procedere.

Elencare la cartella dei plugin
base=os.path.join(tmpdir,'ipv-pro-vendor-optimized')
for root, dirs, files in os.walk(base):
    if root.count(os.sep)-base.count(os.sep) <=1:
        print(root, dirs, files)

/tmp/tmpcf8h9xg3/ipv-pro-vendor-optimized ['includes', 'api', 'admin'] ['README.md', 'audit-tables.sql', 'ipv-pro-vendor.php', '.htaccess', 'database-schema.sql']
/tmp/tmpcf8h9xg3/ipv-pro-vendor-optimized/includes [] ['class-woocommerce-integration.php', 'class-auto-configurator.php', 'class-api-gateway.php', 'class-license-manager.php', 'class-admin-dashboard.php', 'class-credits-manager.php', 'class-remote-updates-server.php', 'class-vendor-core.php', 'class-customer-portal.php', 'class-plans-manager.php', 'class-setup-wizard.php', 'class-admin-status-page.php', 'class-webhook-handler.php', 'class-auto-installer.php']
/tmp/tmpcf8h9xg3/ipv-pro-vendor-optimized/api ['endpoints'] []
/tmp/tmpcf8h9xg3/ipv-pro-vendor-optimized/admin ['assets'] []
Correggere l'elenco dei nomi troncati
Sembrerebbe che la stampa dei nomi venga troncata a causa delle limitazioni del terminale. Per migliorare la visibilit√†, dovrei elencarli correttamente, magari su pi√π righe o abbassando la dimensione del testo per assicurarmi che ogni nome venga visualizzato completamente.

Elencare correttamente i file nel terminale
os.listdir(os.path.join(base,'includes'))

['class-woocommerce-integration.php',
 'class-auto-configurator.php',
 'class-api-gateway.php',
 'class-license-manager.php',
 'class-admin-dashboard.php',
 'class-credits-manager.php',
 'class-remote-updates-server.php',
 'class-vendor-core.php',
 'class-customer-portal.php',
 'class-plans-manager.php',
 'class-setup-wizard.php',
 'class-admin-status-page.php',
 'class-webhook-handler.php',
 'class-auto-installer.php']
Integrare nuove funzionalit√† nella struttura esistente
Esiste gi√† un setup wizard e un pannello di amministrazione, quindi dobbiamo assicurarci che le nuove funzionalit√† si integrino bene nella struttura del plugin senza creare sovrapposizioni. Per fare ci√≤, ispezioner√≤ il file class-vendor-core.php per capire dove vengono gestiti gli hook di inizializzazione.

Esaminando integrazione della funzionalit√† nel plugin
def read(path):
    with open(path,'r',encoding='utf-8',errors='ignore') as f: return f.read()
vendor_core_path=os.path.join(base,'includes','class-vendor-core.php')
print(read(vendor_core_path)[:4000])

<?php
/**
 * IPV Vendor Core Class - VERSIONE CORRETTA
 *
 * Main initialization and setup for the vendor system
 * CON FIX per schedule 'monthly' e miglioramenti
 * 
 * @version 1.1.2-fixed
 * @since 1.1.2
 */

if ( ! defined( 'ABSPATH' ) ) exit;

class IPV_Vendor_Core {

    private static $instance = null;

    public static function instance() {
        if ( null === self::$instance ) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    private function __construct() {
        $this->includes();
        $this->init_hooks();
    }

    private function includes() {
        require_once IPV_VENDOR_DIR . 'includes/class-license-manager.php';
        require_once IPV_VENDOR_DIR . 'includes/class-api-gateway.php';
        require_once IPV_VENDOR_DIR . 'includes/class-credits-manager.php';
        require_once IPV_VENDOR_DIR . 'includes/class-plans-manager.php';
        require_once IPV_VENDOR_DIR . 'includes/class-woocommerce-integration.php';
        require_once IPV_VENDOR_DIR . 'includes/class-remote-updates-server.php';
        require_once IPV_VENDOR_DIR . 'includes/class-webhook-handler.php';
        require_once IPV_VENDOR_DIR . 'includes/class-admin-dashboard.php';
        require_once IPV_VENDOR_DIR . 'includes/class-customer-portal.php';
    }

    private function init_hooks() {
        // ==========================================
        // FIX: Registra schedule 'monthly' PRIMA di usarla!
        // WordPress non ha 'monthly' di default
        // ==========================================
        add_filter( 'cron_schedules', [ $this, 'register_custom_schedules' ] );

        // Initialize components
        IPV_Vendor_License_Manager::instance();
        IPV_Vendor_API_Gateway::instance();
        IPV_Vendor_Credits_Manager::instance();
        IPV_Vendor_Plans_Manager::instance();
        IPV_Vendor_WooCommerce_Integration::instance();
        IPV_Vendor_Remote_Updates_Server::instance();
        IPV_Vendor_Webhook_Handler::instance();
        IPV_Vendor_Admin_Dashboard::instance();
        IPV_Vendor_Customer_Portal::instance();

        // REST API
        add_action( 'rest_api_init', [ $this, 'register_rest_routes' ] );

        // Backward compatibility: legacy admin page slug
        add_action( 'admin_init', [ $this, 'maybe_redirect_legacy_admin_pages' ] );

        // Cron hooks
        add_action( 'ipv_vendor_reset_credits', [ $this, 'reset_monthly_credits' ] );
        add_action( 'ipv_vendor_clear_cache', [ 'IPV_Vendor_API_Gateway', 'clear_old_cache' ] );
        add_action( 'ipv_vendor_cleanup_logs', [ $this, 'cleanup_old_logs' ] );

        // Admin enqueue
        add_action( 'admin_enqueue_scripts', [ $this, 'admin_enqueue_scripts' ] );

        // Health check endpoint (non autenticato per monitoring)
        add_action( 'rest_api_init', [ $this, 'register_health_endpoint' ] );
    }

    /**
     * Backward compatibility for older bookmarks/links.
     * Some older builds used admin.php?page=ipv-vendor.
     */
    public function maybe_redirect_legacy_admin_pages() {
        if ( ! is_admin() ) {
            return;
        }
        if ( ! current_user_can( 'manage_options' ) ) {
            return;
        }
        $page = isset( $_GET['page'] ) ? sanitize_key( wp_unslash( $_GET['page'] ) ) : '';
        if ( 'ipv-vendor' === $page ) {
            wp_safe_redirect( admin_url( 'admin.php?page=ipv-vendor-dashboard' ) );
            exit;
        }
    }

    /**
     * FIX: Registra schedules personalizzate
     * WordPress non ha 'monthly', 'weekly' etc di default
     */
    public function register_custom_schedules( $schedules ) {
        // Monthly - ogni 30 giorni
        $schedules['monthly'] = [
            'interval' => 30 * DAY_IN_SECONDS,
            'display' => __( 'Una volta al mese', 'ipv-pro-vendor' )
        ];

        // Weekly - ogni 7 giorni
        $schedules['weekly'] = [
            'interval' => 7 * DAY_IN_SECONDS,
           
Esaminare l'inizializzazione attorno alla linea 51
Dobbiamo scorrere un po' pi√π in profondit√† nel codice intorno alla linea 51 del file init_hooks per capire come vengono gestiti i hook di inizializzazione. Questo mi aiuter√† a garantire che l'integrazione delle nuove funzionalit√† sia coerente con la struttura esistente e senza problemi.

Individuazione e visualizzazione della funzione init_hooks
content=read(vendor_core_path)
m=re.search(r'function init_hooks\(\).*?\{', content, re.S)
m.start(), content[m.start():m.start()+800]

(1330,
 "function init_hooks() {\n        // ==========================================\n        // FIX: Registra schedule 'monthly' PRIMA di usarla!\n        // WordPress non ha 'monthly' di default\n        // ==========================================\n        add_filter( 'cron_schedules', [ $this, 'register_custom_schedules' ] );\n\n        // Initialize components\n        IPV_Vendor_License_Manager::instance();\n        IPV_Vendor_API_Gateway::instance();\n        IPV_Vendor_Credits_Manager::instance();\n        IPV_Vendor_Plans_Manager::instance();\n        IPV_Vendor_WooCommerce_Integration::instance();\n        IPV_Vendor_Remote_Updates_Server::instance();\n        IPV_Vendor_Webhook_Handler::instance();\n        IPV_Vendor_Admin_Dashboard::instance();\n        IPV_Vendor_Customer_Portal::instance();\n\n   ")
Visualizzando porzione di testo da init_hooks
print(content[m.start():m.start()+2000])

function init_hooks() {
        // ==========================================
        // FIX: Registra schedule 'monthly' PRIMA di usarla!
        // WordPress non ha 'monthly' di default
        // ==========================================
        add_filter( 'cron_schedules', [ $this, 'register_custom_schedules' ] );

        // Initialize components
        IPV_Vendor_License_Manager::instance();
        IPV_Vendor_API_Gateway::instance();
        IPV_Vendor_Credits_Manager::instance();
        IPV_Vendor_Plans_Manager::instance();
        IPV_Vendor_WooCommerce_Integration::instance();
        IPV_Vendor_Remote_Updates_Server::instance();
        IPV_Vendor_Webhook_Handler::instance();
        IPV_Vendor_Admin_Dashboard::instance();
        IPV_Vendor_Customer_Portal::instance();

        // REST API
        add_action( 'rest_api_init', [ $this, 'register_rest_routes' ] );

        // Backward compatibility: legacy admin page slug
        add_action( 'admin_init', [ $this, 'maybe_redirect_legacy_admin_pages' ] );

        // Cron hooks
        add_action( 'ipv_vendor_reset_credits', [ $this, 'reset_monthly_credits' ] );
        add_action( 'ipv_vendor_clear_cache', [ 'IPV_Vendor_API_Gateway', 'clear_old_cache' ] );
        add_action( 'ipv_vendor_cleanup_logs', [ $this, 'cleanup_old_logs' ] );

        // Admin enqueue
        add_action( 'admin_enqueue_scripts', [ $this, 'admin_enqueue_scripts' ] );

        // Health check endpoint (non autenticato per monitoring)
        add_action( 'rest_api_init', [ $this, 'register_health_endpoint' ] );
    }

    /**
     * Backward compatibility for older bookmarks/links.
     * Some older builds used admin.php?page=ipv-vendor.
     */
    public function maybe_redirect_legacy_admin_pages() {
        if ( ! is_admin() ) {
            return;
        }
        if ( ! current_user_can( 'manage_options' ) ) {
            return;
        }
        $page = isset( $_GET['page'] ) ? sanitize_key( wp_unslash( $_GET['page'] ) ) 
Esaminare l'inclusione nel file class-api-gateway.php
Abbiamo gi√† aggiunto un alias in precedenza, e IPV_Vendor_API_Gateway serve come un "shim" per fare riferimento alla classe ottimizzata. Ora dobbiamo esaminare includes/class-api-gateway.php per assicurarci che il "shim" sia correttamente incluso e funzionante come previsto.

Esaminando shim nel file class-api-gateway.php
api_gateway_path=os.path.join(base,'includes','class-api-gateway.php')
print(read(api_gateway_path)[:500])

<?php
/**
 * IPV API Gateway - VERSIONE OTTIMIZZATA E SICURA
 *
 * Versione ottimizzata con:
 * - ‚úÖ Rate limiting per license (anti-abuse)
 * - ‚úÖ Request validation robusta
 * - ‚úÖ Caching transcript server-side
 * - ‚úÖ API key rotation intelligente
 * - ‚úÖ Audit logging completo
 * - ‚úÖ DDoS protection (IP + User-Agent filtering)
 * - ‚úÖ Response compression
 * - ‚úÖ Performance monitoring
 * - ‚úÖ Automatic failover
 *
 * @package IPV_Pro_Vendor
 * @version 1.4.0-optimized
 */

if ( ! defined( 'ABSPATH
Ricerca della definizione della classe shim
Devo cercare la definizione della classe "shim" per capire come viene implementata. Potrebbe essere importante per garantire che venga correttamente inclusa e funzioni come previsto. Vediamo dove √® definita nel codice, cos√¨ posso approfondire e capire meglio come integrarla nel progetto.

Cercando definizione della classe shim
text=read(api_gateway_path)
re.findall(r'class\s+IPV_Vendor_API_Gateway\b', text)[:5], 'Optimized' in text

(['class IPV_Vendor_API_Gateway', 'class IPV_Vendor_API_Gateway'], True)
Esaminando la classe dell'auto-installer e la classe DB
Ho trovato che il file contiene entrambe le classi, il che √® fantastico. Ora dobbiamo aggiungere la classe per l'installazione del database. Potrebbe essere utile vedere se quella esistente contiene gi√† un file come database-schema.sql o uno script per l'installazione automatica. Quindi, ispezioniamo la classe dell'auto-installer.

Ispezionando la classe auto-installer
print(read(os.path.join(base,'includes','class-auto-installer.php'))[:800])

<?php
/**
 * Auto-Installer for IPV Pro Vendor Server
 *
 * Handles automatic installation and configuration on plugin activation
 *
 * @package IPV_Pro_Vendor
 * @version 1.4.0-optimized
 */

if (!defined('ABSPATH')) {
    exit;
}

class IPV_Pro_Vendor_Auto_Installer {

    /**
     * Run the installation wizard
     */
    public static function install() {
        // Create database tables
        self::create_tables();

        // Set default options
        self::set_default_options();

        // Schedule CRON jobs
        self::schedule_cron();

        // Set installation flag
        update_option('ipv_vendor_installed', true);
        update_option('ipv_vendor_version', '1.4.0-optimized');
        update_option('ipv_vendor_install_date', current_time('mysql'));

        // Redire
Esaminando la funzione create_tables
La funzione gi√† crea le tabelle, quindi dobbiamo vedere come lo fa. Ispezionando la funzione create_tables, possiamo capire meglio come gestisce l'installazione del database e quale schema utilizza, per determinarne l'integrazione con la nostra nuova classe di installazione.

Ispezionando la funzione create_tables
ai=read(os.path.join(base,'includes','class-auto-installer.php'))
m=re.search(r'function create_tables\(\).*?\{', ai, re.S)
print(ai[m.start():m.start()+1600])

function create_tables() {
        global $wpdb;

        require_once(ABSPATH . 'wp-admin/includes/upgrade.php');

        $charset_collate = $wpdb->get_charset_collate();

        // Licenses table
        $sql_licenses = "CREATE TABLE IF NOT EXISTS {$wpdb->prefix}ipv_licenses (
            id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
            license_key varchar(32) NOT NULL,
            email varchar(255) NOT NULL,
            product_id bigint(20) NULL,
            plan varchar(50) DEFAULT 'trial',
            credits_total int DEFAULT 10,
            credits_remaining int DEFAULT 10,
            credits_reset_date datetime NULL,
            status varchar(20) DEFAULT 'active',
            valid_until datetime NULL,
            created_at datetime DEFAULT CURRENT_TIMESTAMP,
            updated_at datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            PRIMARY KEY (id),
            UNIQUE KEY license_key (license_key),
            KEY email (email),
            KEY status (status)
        ) $charset_collate;";

        // License activations table
        $sql_activations = "CREATE TABLE IF NOT EXISTS {$wpdb->prefix}ipv_license_activations (
            id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
            license_id bigint(20) UNSIGNED NOT NULL,
            site_url varchar(255) NOT NULL,
            activated_at datetime DEFAULT CURRENT_TIMESTAMP,
            last_seen datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            PRIMARY KEY (id),
            KEY license_id (license_id),
            KEY site_url (site_url)
Verificando la struttura del database dell'installatore automatico
L'auto-installer crea una tabella delle licenze con uno schema diverso da quello che avevamo pianificato, includendo campi come l'email, i crediti totali, ecc. Inoltre, esiste anche una tabella ipv_license_activations e sembra esserci anche un "ledger". Dobbiamo continuare esaminando questi componenti per capire meglio come si integrano.

Analizzando la creazione della tabella licenze
print(ai[m.start()+1600:m.start()+3200])


        ) $charset_collate;";

        // API logs table
        $sql_api_logs = "CREATE TABLE IF NOT EXISTS {$wpdb->prefix}ipv_api_logs (
            id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
            license_id bigint(20) NULL,
            endpoint varchar(100) NOT NULL,
            resource_id varchar(100) NULL,
            status_code int NOT NULL,
            response_size int DEFAULT 0,
            attempts int DEFAULT 1,
            cached tinyint(1) DEFAULT 0,
            ip_address varchar(45) NULL,
            user_agent varchar(255) NULL,
            created_at datetime DEFAULT CURRENT_TIMESTAMP,
            PRIMARY KEY (id),
            KEY license_id (license_id),
            KEY endpoint (endpoint),
            KEY created_at (created_at),
            KEY cached (cached),
            KEY status_code (status_code)
        ) $charset_collate COMMENT='Audit log di tutte le chiamate API';";

        // Security log table
        $sql_security_log = "CREATE TABLE IF NOT EXISTS {$wpdb->prefix}ipv_security_log (
            id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
            event_type varchar(50) NOT NULL,
            event_data text NULL,
            ip_address varchar(45) NULL,
            user_agent varchar(255) NULL,
            created_at datetime DEFAULT CURRENT_TIMESTAMP,
            PRIMARY KEY (id),
            KEY event_type (event_type),
            KEY ip_address (ip_address),
            KEY created_at (created_at)
        ) $charset_collate COMMENT='Log eventi di sicurezza';";

        // Performance stats table
        $sql_performan
Adattamento della struttura del database alla nuova richiesta
Il plugin ha gi√† un proprio schema che non corrisponde al nostro nuovo piano, ma l'utente ha chiesto una creazione SQL pronta. Potremmo allinearlo al design concordato, aggiungendo colonne per "credits_monthly" e "credits_extra" e aggiungendo una nuova tabella "ledger" senza rompere nulla. Tuttavia, dobbiamo stare attenti a non modificare tabelle esistenti in modo da non interrompere il codice corrente.

Adattare la struttura del database per la gestione delle licenze e dei crediti
Per evitare problemi, √® meglio mantenere la tabella esistente e aggiungere colonne extra come site_url e user_id, eventualmente usando license_activations. Per i crediti, possiamo aggiornare le colonne esistenti (come credits_total e credits_remaining) senza rompere le funzionalit√† esistenti, ma dobbiamo esaminare come gestire i nuovi tipi di crediti.

Valutazione piano di adattamento schema database
credits_path=os.path.join(base,'includes','class-credits-manager.php')
print(read(credits_path)[:1200])

<?php
/**
 * IPV Credits Manager
 *
 * Gestisce sistema crediti mensili, reset automatico e statistiche usage
 */

if ( ! defined( 'ABSPATH' ) ) exit;

class IPV_Vendor_Credits_Manager {

    private static $instance = null;

    public static function instance() {
        if ( null === self::$instance ) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    /**
     * Check if license has enough credits
     */
    public function has_credits( $license, $required = 1 ) {
        return (int) $license->credits_remaining >= $required;
    }

    /**
     * Use credits
     */
    public function use_credits( $license_id, $amount = 1 ) {
        global $wpdb;

        $wpdb->query( $wpdb->prepare(
            "UPDATE {$wpdb->prefix}ipv_licenses
            SET credits_remaining = GREATEST(0, credits_remaining - %d)
            WHERE id = %d",
            $amount,
            $license_id
        ));

        // Update daily stats
        $this->update_daily_stats( $license_id, 'credits_used', $amount );
        $this->update_daily_stats( $license_id, 'transcripts_count', 1 );

        error_log( sprintf(
            'IPV Vendor: Credits used -
Verificando la gestione dei crediti
Stavo pensando che il gestore dei crediti usa credits_remaining e credits_total, ma forse c'√® anche una logica di reset. Devo verificare se esiste una funzione di reset per assicurarci che tutto venga gestito correttamente, senza interrompere altre funzioni.

Verifica frequenza reset e parametri crediti
txt=read(credits_path)
for pat in ['reset','monthly','credits_total','credits_remaining']:
    print(pat, txt.count(pat))

reset 36
monthly 2
credits_total 13
credits_remaining 12
Cercando la funzione di reset
Ora devo cercare una possibile funzione di reset nel codice, per capire se esiste un meccanismo per resettare i crediti o altre variabili legate ai crediti. Questo mi aiuter√† a capire come vengono gestiti e se c'√® qualche aspetto da sistemare.

Cercando funzione di reset
m=re.search(r'function reset_monthly_credits.*?\{', txt, re.S)
print(txt[m.start():m.start()+1500])

---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Cell In[15], line 2
      1 m=re.search(r'function reset_monthly_credits.*?\{', txt, re.S)
----> 2 print(txt[m.start():m.start()+1500])

AttributeError: 'NoneType' object has no attribute 'start'
Cercando 'reset mensile'
Non ho trovato il nome di una funzione, quindi ora cercher√≤ usando il termine "reset mensile". Questo potrebbe portarmi a una funzione o un metodo che si occupa del riavvio mensile dei crediti o parametri simili, come sospetto. Vediamo se trovo qualcosa.

Ricerca di funzioni con "reset" nel nome
import re
matches=re.findall(r'function\s+([a-zA-Z0-9_]+).*reset', txt)
matches[:20], len(matches)

(['days_until_reset', 'send_credits_'], 2)
Cercando azioni programmate
Mi serve localizzare le azioni programmate per capire come vengono gestiti i reset o le attivit√† periodiche. Devo trovare dove sono gestite queste azioni nel codice, in modo da ottenere informazioni su come vengono eseguite e se ci sono riferimenti a operazioni mensili o simili.

Localizzando azioni del programma
for s in ['ipv_vendor_monthly','reset_credits','ipv_vendor_monthly_reset','monthly_reset']:
    if s in txt:
        print("found", s)

Esaminando classe plans-manager.php
Penso che la gestione delle azioni programmate possa trovarsi nel gestore dei piani. Quindi, voglio ispezionare il file class-plans-manager.php per vedere se contiene la logica relativa alla pianificazione o alle azioni periodiche, come i reset mensili, che potrebbero essere gi√† implementate l√¨.

Ispezionando il file class-plans-manager.php
plans=read(os.path.join(base,'includes','class-plans-manager.php'))
print(plans[:1200])

<?php
/**
 * IPV Plans Manager
 *
 * Gestisce i piani SaaS configurabili dall'admin
 *
 * @version 1.3.17
 *
 * CHANGELOG v1.3.17 (2025-12-11):
 * - FIX CRITICO: Descrizioni prodotti WooCommerce corrotte risolto
 * - Aggiunto metodo emoji_to_html_entities() per conversione sicura emoji
 * - Aggiornato generate_product_description() con descrizioni pi√π ricche
 * - Emoji convertite in HTML entities (compatibile UTF8 standard)
 * - Descrizioni strutturate in 4 sezioni (Header, Cosa Include, Funzionalit√†, Supporto)
 */

if ( ! defined( 'ABSPATH' ) ) exit;

class IPV_Vendor_Plans_Manager {

    private static $instance = null;
    
    /** @var string Option name for storing plans */
    const OPTION_NAME = 'ipv_saas_plans';

    public static function instance() {
        if ( null === self::$instance ) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    private function __construct() {
        // Hooks
        add_action( 'admin_menu', [ $this, 'add_admin_menu' ], 15 );
        add_filter( 'ipv_vendor_plan_options', [ $this, 'get_plan_options' ] );
    }

    /**
     * Add submenu page
     */
    public function add_admin_menu() {
       
Verifica integrazione pagina Licenze
Il plugin ha gi√† dei menu per gli amministratori, e potrebbe esserci un conflitto con la nuova pagina Licenze. C'√® una classe class-admin-dashboard.php che potrebbe essere utile. Poich√© il utente ha chiesto esplicitamente una lista di licenze, possiamo aggiungerla come sottogruppo nel menu esistente dell'IPV Vendor Dashboard.

Verificando integrazione della pagina Licenze
dash=read(os.path.join(base,'includes','class-admin-dashboard.php'))
print(dash[:500])

<?php
/**
 * IPV Admin Dashboard
 *
 * Dashboard amministrativa per gestione licenze, analytics, stats
 */

if ( ! defined( 'ABSPATH' ) ) exit;

class IPV_Vendor_Admin_Dashboard {

    private static $instance = null;

    public static function instance() {
        if ( null === self::$instance ) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    private function __construct() {
        add_action( 'admin_menu', [ $this, 'add_admin_menu' ] );
    }

Continuando configurazione menu
Devo proseguire con la configurazione del menu. Sembra che dobbiamo aggiungere la nuova pagina Licenze come sottogruppo della dashboard dell'IPV Vendor. Procediamo con questa integrazione in modo che non ci siano conflitti con i menu esistenti, monitorando correttamente la struttura.

Estraendo configurazione menu amministratore
m=re.search(r'function add_admin_menu.*?\{', dash, re.S)
print(dash[m.start():m.start()+1200])

function add_admin_menu() {
        // Main menu
        add_menu_page(
            'IPV Pro Vendor',
            'IPV Pro Vendor',
            'manage_options',
            'ipv-vendor-dashboard',
            [ $this, 'render_dashboard' ],
            'dashicons-cloud',
            30
        );

        // Dashboard (same as parent)
        add_submenu_page(
            'ipv-vendor-dashboard',
            'Dashboard',
            'Dashboard',
            'manage_options',
            'ipv-vendor-dashboard',
            [ $this, 'render_dashboard' ]
        );

        // Licenses
        add_submenu_page(
            'ipv-vendor-dashboard',
            'Licenze',
            'Licenze',
            'manage_options',
            'ipv-vendor-licenses',
            [ $this, 'render_licenses' ]
        );

        // Analytics
        add_submenu_page(
            'ipv-vendor-dashboard',
            'Analytics',
            'Analytics',
            'manage_options',
            'ipv-vendor-analytics',
            [ $this, 'render_analytics' ]
        );

        // Settings
        add_submenu_page(
            'ipv-vendor-dashboard',
            'Impostazioni',
            'Impostazi
Verificando licenze nelel impostazioni amministrative
Il menu esiste gi√†, quindi aggiunger√≤ la pagina "Licenze" come sottogruppo per evitare duplicazioni. Ma il plugin potrebbe gi√† contenere una vista delle licenze. Quindi, cercher√≤ "licenza" nel pannello di amministrazione per evitare sovrapposizioni o conflitti.

Verificando esistenza pagina licenze nel menu
'Licenze' in dash, dash.count('license')

(True, 95)
Cercando la funzione render_licenses
C'√® una funzione chiamata "render_licenses" che potrebbe essere utile. Cercher√≤ di trovarla per vedere se gi√† gestisce la visualizzazione delle licenze, in modo da non duplicare il lavoro. Verifico se esiste e come viene utilizzata nel codice corrente.

Cercando licenze di rendering
for name in ['render_licenses','licenses','Licenze']:
    idx=dash.find(name)
    print(name, idx)

render_licenses 1296
licenses 1263
Licenze 1176
Cercando licenze di rendering
print(dash[1160:1500])

',
            'Licenze',
            'Licenze',
            'manage_options',
            'ipv-vendor-licenses',
            [ $this, 'render_licenses' ]
        );

        // Analytics
        add_submenu_page(
            'ipv-vendor-dashboard',
            'Analytics',
            'Analytics',
            'manage_options',
          
Esaminando render_licenses nel dashboard
C'√® gi√† una pagina "Licenze" nel dashboard, quindi dovremmo estendere quella pagina esistente invece di crearne una nuova. Ora, dar√≤ un'occhiata alla funzione render_licenses nel file class-admin-dashboard.php per capire come viene gestita e come possiamo modificarla.

Ispezionando la funzione render_licenses
m=re.search(r'function render_licenses\(\).*?\{', dash, re.S)
print(dash[m.start():m.start()+2000])

function render_licenses() {
        global $wpdb;

        // Handle manual license creation
        if ( isset( $_POST['ipv_create_license'] ) ) {
            check_admin_referer( 'ipv_create_license_nonce' );

            $email = sanitize_email( $_POST['license_email'] ?? '' );
            $variant = sanitize_text_field( $_POST['license_variant'] ?? 'starter' );
            $expires_days = absint( $_POST['license_expires'] ?? 0 );
            
            // Get plan data
            $plans_manager = IPV_Vendor_Plans_Manager::instance();
            $plan = $plans_manager->get_plan( $variant );
            
            // Use plan defaults or form overrides
            $credits = ! empty( $_POST['license_credits'] ) 
                ? absint( $_POST['license_credits'] ) 
                : ( $plan['credits'] ?? 25 );
            $activations = ! empty( $_POST['license_activations'] ) 
                ? absint( $_POST['license_activations'] ) 
                : ( $plan['activations'] ?? 1 );

            if ( empty( $email ) ) {
                echo '<div class="notice notice-error"><p>Email obbligatoria!</p></div>';
            } else {
                // Generate license key
                $license_manager = IPV_Vendor_License_Manager::instance();
                $license_key = $license_manager->generate_license_key();

                // Calculate expiry
                $expires_at = $expires_days > 0 
                    ? date( 'Y-m-d H:i:s', strtotime( "+{$expires_days} days" ) ) 
                    : null;

                // Insert license
                $inserted = $wpdb->insert(
                    $wpdb->prefix . 'ipv_licenses',
                    [
                        'license_key' => $license_key,
                        'order_id' => 0,
                        'product_id' => 0,
                        'user_id' => get_current_user_id(),
                        'email' => $email,
                        'status' => 'active',
                 
Esaminando il database per user_id nelle licenze
La funzione render_licenses sembra gestire la creazione delle licenze e mostrare una tabella, utilizzando le colonne user_id/email. Tuttavia, nel codice dell'auto-installatore, la tabella delle licenze sembrava usare solo email e product_id, senza user_id. Dovrei controllare meglio lo schema completo della tabella e gli script SQL, verificando come viene gestita la colonna user_id.

Ispezionando schema licenze per user_id
sql_part=re.search(r'CREATE TABLE IF NOT EXISTS.*ipv_licenses.*?\);', ai, re.S).group(0)
'user_id' in sql_part, sql_part[:800]

(False,
 "CREATE TABLE IF NOT EXISTS {$wpdb->prefix}ipv_licenses (\n            id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,\n            license_key varchar(32) NOT NULL,\n            email varchar(255) NOT NULL,\n            product_id bigint(20) NULL,\n            plan varchar(50) DEFAULT 'trial',\n            credits_total int DEFAULT 10,\n            credits_remaining int DEFAULT 10,\n            credits_reset_date datetime NULL,\n            status varchar(20) DEFAULT 'active',\n            valid_until datetime NULL,\n            created_at datetime DEFAULT CURRENT_TIMESTAMP,\n            updated_at datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            PRIMARY KEY (id),\n            UNIQUE KEY license_key (license_key),\n            KEY email (email),\n            KEY status (status)")
Verifica della compatibilit√† con la tabella delle licenze
Nell'auto-installatore, la creazione della tabella non include user_id, ma l'amministratore si aspetta che sia presente. Potrebbe esserci una discrepanza se il file √® stato troncato durante la lettura. Comunque, l'attivazione √® riuscita, quindi √® probabile che la tabella esista gi√† dalla versione precedente. Ora, dovrei assicurarmi che le modifiche siano compatibili con la tabella attuale, aggiungendo le colonne e nuove tabelle richieste.

Verificando la compatibilit√† dello schema del database
schema=read(os.path.join(base,'database-schema.sql'))
print(schema[:1200])

-- IPV Pro Vendor Database Schema
-- Generated: 2024-12-06
-- WordPress tables prefix: wp_ (adjust as needed)

-- ====================
-- TABLE: Licenses
-- ====================
CREATE TABLE IF NOT EXISTS `wp_ipv_licenses` (
    `id` BIGINT(20) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    `license_key` VARCHAR(100) UNIQUE NOT NULL,
    `order_id` BIGINT(20) UNSIGNED NOT NULL,
    `product_id` BIGINT(20) UNSIGNED NOT NULL,
    `user_id` BIGINT(20) UNSIGNED NOT NULL,
    `email` VARCHAR(255) NOT NULL,
    `status` VARCHAR(20) DEFAULT 'active',
    `variant_slug` VARCHAR(50) NOT NULL,
    `credits_total` INT UNSIGNED NOT NULL DEFAULT 10,
    `credits_remaining` INT UNSIGNED NOT NULL DEFAULT 10,
    `credits_reset_date` DATE NOT NULL,
    `activation_limit` INT UNSIGNED DEFAULT 1,
    `activation_count` INT UNSIGNED DEFAULT 0,
    `expires_at` DATETIME NULL,
    `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP,
    `updated_at` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX `idx_license_key` (`license_key`),
    INDEX `idx_user_id` (`user_id`),
    INDEX `idx_status` (`status`),
    INDEX `idx_product_id` (`product_id`),
    INDEX `idx_email` (`email`)
) ENGINE=In
Pianificazione delle modifiche alla gestione dei crediti
Il sistema esistente include gi√† user_id, activation_limit, e credits_reset_date. Le nostre modifiche dovrebbero aggiungere site_url e site_unlock_at oltre a distinguere i crediti mensili da quelli extra. Se aggiungiamo crediti extra, sar√† necessario registrarli separatamente per preservarne il valore durante il reset mensile.

Revisione della gestione dei crediti
Per mantenere la compatibilit√† con il sistema esistente, possiamo aggiungere le colonne credits_extra, credits_monthly e credits_used_month, mantenendo comunque credits_remaining. Durante l'azione di reset, aggiorneremo sia le colonne vecchie che quelle nuove, assicurandoci che i crediti rimanenti vengano correttamente calcolati e sincronizzati.

Gestione del consumo dei crediti
Per evitare di conteggiare due volte i crediti extra, dovremmo rivedere la funzione di consumo. Una soluzione potrebbe essere usare una logica che calcoli correttamente il totale dei crediti rimanenti, includendo anche i crediti extra separati, senza sovrascriverli nei reset. L'idea migliore sembra essere quella di conservare tutti i crediti extra sotto una nuova colonna.

Gestione avanzata dei crediti
Quando si consumano crediti, dobbiamo prestare attenzione a come decremettiamo credits_remaining senza confondere i crediti extra. L'approccio migliore potrebbe essere uno che separi chiaramente i crediti mensili da quelli extra, evitando che i crediti extra vengano ripristinati ogni mese. Aggiungerei tre colonne separate per gestirli in modo pi√π preciso.

Rivedere la gestione dei crediti rimanenti
Per gestire correttamente i crediti, devo derivare credits_remaining come somma di credits_monthly, credits_extra e sottrarre credits_used_month. Continuer√≤ a usare credits_remaining ma lo sincronizzer√≤ con il valore derivato. Modificher√≤ anche la logica di consumo per usare queste nuove colonne e garantire la sincronizzazione corretta.

Modificando gestione crediti e colonne aggiuntive
import re, os
txt=read(credits_path)
m=re.search(r'function\s+use_credits\(', txt)
m.start()

635
Implementing credits system modifications and extra balance
print(txt[m.start():m.start()+900])

function use_credits( $license_id, $amount = 1 ) {
        global $wpdb;

        $wpdb->query( $wpdb->prepare(
            "UPDATE {$wpdb->prefix}ipv_licenses
            SET credits_remaining = GREATEST(0, credits_remaining - %d)
            WHERE id = %d",
            $amount,
            $license_id
        ));

        // Update daily stats
        $this->update_daily_stats( $license_id, 'credits_used', $amount );
        $this->update_daily_stats( $license_id, 'transcripts_count', 1 );

        error_log( sprintf(
            'IPV Vendor: Credits used - License ID %d, Amount: %d',
            $license_id,
            $amount
        ));

        return true;
    }

    /**
     * Get credits info for license
     */
    public function get_credits_info( $license ) {
        $credits_remaining = (int) $license->credits_remaining;
        $credits_total = (int) $license->credits_tota
Aggiornando la logica di utilizzo e reset dei crediti
Dobbiamo aggiornare la funzione use_credits e verificare anche la logica di reset dei crediti, che potrebbe essere presente nel gestore dei crediti. Dovrei cercare parole come "reset_credits" per capire meglio come viene gestito il reset e adattare di conseguenza la logica di consumo.

Cercando logica di reset crediti
for pat in ['credits_reset_date','reset_date','reset_']:
    idx=txt.find(pat)
    print(pat, idx)

credits_reset_date 1979
reset_date 1954
reset_ 1954
Aggiornamento del sistema di crediti e reset
print(txt[1800:2500])

            'credits_remaining' => $credits_remaining,
            'credits_used' => $credits_used,
            'percentage' => $percentage,
            'reset_date' => $license->credits_reset_date,
            'reset_date_formatted' => date_i18n( 'd/m/Y', strtotime( $license->credits_reset_date ) ),
            'days_until_reset' => $this->days_until_reset( $license->credits_reset_date ),
            'status' => $this->get_credit_status( $credits_remaining, $credits_total )
        ];
    }

    /**
     * Get credit status (ok, low, critical, depleted)
     */
    private function get_credit_status( $remaining, $total ) {
        if ( $remaining <= 0 ) {
            return 'depleted';
    
Esplorando la logica di reset dei crediti
Potrebbe esserci una logica di reset in un'altra parte, forse nella classe class-woocommerce-integration. Mi sembra utile cercare un aggiornamento in merito al credits_reset_date. Cos√¨ potr√≤ trovare dove viene gestito il reset e come si allinea con la nuova logica che voglio implementare.

Cercando aggiornamenti di credits_reset_date nei file
import glob, os, re
def find_in_files(root, pattern):
    res=[]
    for path in glob.glob(root+'/**/*.php', recursive=True):
        try:
            t=read(path)
        except: 
            continue
        if pattern in t:
            res.append(path)
    return res
files=find_in_files(base, 'credits_reset_date')
files

['/tmp/tmpcf8h9xg3/ipv-pro-vendor-optimized/includes/class-license-manager.php',
 '/tmp/tmpcf8h9xg3/ipv-pro-vendor-optimized/includes/class-admin-dashboard.php',
 '/tmp/tmpcf8h9xg3/ipv-pro-vendor-optimized/includes/class-credits-manager.php',
 '/tmp/tmpcf8h9xg3/ipv-pro-vendor-optimized/includes/class-vendor-core.php',
 '/tmp/tmpcf8h9xg3/ipv-pro-vendor-optimized/includes/class-auto-installer.php',
 '/tmp/tmpcf8h9xg3/ipv-pro-vendor-optimized/api/endpoints/class-gateway-endpoints.php']
Esaminando la funzione di reset del gestore delle licenze
Mi sembra che sarebbe utile dare un'occhiata alla funzione di reset nel gestore delle licenze. Potrebbe esserci qualcosa di rilevante l√¨ che possiamo utilizzare o adeguare per il nostro nuovo sistema di gestione dei crediti. Vediamo cosa troviamo.

Ispezione della funzione di reset del gestore licenze
lm=read(os.path.join(base,'includes','class-license-manager.php'))
# find cron hook
for pat in ['reset','cron','schedule','credits_reset_date']:
    print(pat, lm.count(pat))

reset 5
cron 0
schedule 0
credits_reset_date 3
Ispezionando la funzione di reset del gestore licenze
print(lm[:900])

<?php
/**
 * IPV License Manager
 *
 * Handles license generation, validation, activation, and deactivation
 */

if ( ! defined( 'ABSPATH' ) ) exit;

class IPV_Vendor_License_Manager {

    private static $instance = null;

    public static function instance() {
        if ( null === self::$instance ) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    /**
     * Generate unique license key
     */
    public function generate_license_key() {
        $key = strtoupper( sprintf(
            '%s-%s-%s-%s',
            $this->random_string( 4 ),
            $this->random_string( 4 ),
            $this->random_string( 4 ),
            $this->random_string( 4 )
        ));

        // Ensure unique
        global $wpdb;
        $exists = $wpdb->get_var( $wpdb->prepare(
            "SELECT id FROM {$wpdb->prefix}ipv_licenses WHERE license_key = %s"
Esaminando il metodo di reset
Penso che sia il caso di cercare il metodo di reset. Potrebbe esserci qualcosa in quella funzione che ci aiuter√† a gestire meglio il nostro sistema di crediti. Dobbiamo capire come si applica e verificare se possiamo adattarlo alle nostre necessit√†.

Cercando metodo di reset
m=re.search(r'function\s+maybe_reset_credits', lm)
m

Ricerca del testo "reset credits"
Voglio cercare il testo "reset credits" per capire come viene gestito il reset dei crediti. Potrei trovare qualcosa che potrebbe aiutarmi ad adattare o migliorare il processo che stiamo cercando di definire, quindi √® un passo importante per risolvere il problema.

Cercando testo "reset credits"
import re
for m in re.finditer(r'reset', lm):
    if m.start()<2000:
        pass
# show snippet around first occurrence after methods
idx=lm.find('reset')
lm[idx-200:idx+400]

"1 year\n            $expires_at = date( 'Y-m-d H:i:s', strtotime( '+1 year' ) );\n        }\n\n        // Generate license\n        $license_key = $this->generate_license_key();\n\n        // Calculate next reset date (first day of next month)\n        $credits_reset_date = date( 'Y-m-01', strtotime( '+1 month' ) );\n\n        // Insert license\n        $inserted = $wpdb->insert(\n            $wpdb->prefix . 'ipv_licenses',\n            [\n                'license_key' => $license_key,\n                'order_id' => $order_id,\n                'product_id' => $product_id,\n                'user_id' => $order->"
Ricerca pi√π mirata su "credits_reset_date"
Sospetto che l'uso di "..." potrebbe essere dovuto a modifiche precedenti, quindi cercher√≤ in modo pi√π preciso ‚Äúcredits_reset_date‚Äù per trovare eventuali riferimenti specifici. Questo dovrebbe aiutarmi a ottenere informazioni meglio contestualizzate e non troncate.

Ricerca esatta dell'uso di "credits_reset_date"
for m in re.finditer('credits_reset_date', lm):
    print(m.start())

2927
3562
3586
Cercando utilizzo di "credits_reset_date"
print(lm[2840:3660])

icense_key();

        // Calculate next reset date (first day of next month)
        $credits_reset_date = date( 'Y-m-01', strtotime( '+1 month' ) );

        // Insert license
        $inserted = $wpdb->insert(
            $wpdb->prefix . 'ipv_licenses',
            [
                'license_key' => $license_key,
                'order_id' => $order_id,
                'product_id' => $product_id,
                'user_id' => $order->get_user_id(),
                'email' => $order->get_billing_email(),
                'status' => 'active',
                'variant_slug' => $variant_slug,
                'credits_total' => $credits_total,
                'credits_remaining' => $credits_total,
                'credits_reset_date' => $credits_reset_date,
                'activation_limit' => $activation_limi
Esplorando cron nei componenti correlati
La data di reset dei crediti √® stata calcolata, ma la vera logica di cron potrebbe trovarsi in "vendor-core" o "credits-manager". Ora cercher√≤ nel componente "vendor-core" per vedere se troviamo riferimenti come "ipv_vendor_reset" o "reset_credits", per identificare il processo corretto.

Ispezionando cron nel vendor-core
vc=read(vendor_core_path)
for pat in ['reset','cron','schedule_event','wp_schedule_event','ipv_vendor']:
    if pat in vc:
        print(pat, vc.count(pat))

reset 10
cron 3
schedule_event 3
wp_schedule_event 3
ipv_vendor 20
Ispezionando la pianificazione del cron in vendor-core
# show cron scheduling section
idx=vc.find('wp_schedule_event')
print(vc[idx-300:idx+900])

dor_cleanup_logs' );

        // Calcola timestamp primo giorno del prossimo mese alle 02:00 UTC
        $first_day_next_month = strtotime( 'first day of next month 02:00:00' );

        // Schedule reset crediti mensile
        if ( ! wp_next_scheduled( 'ipv_vendor_reset_credits' ) ) {
            wp_schedule_event(
                $first_day_next_month,
                'monthly',
                'ipv_vendor_reset_credits'
            );
        }

        // Schedule pulizia cache settimanale
        if ( ! wp_next_scheduled( 'ipv_vendor_clear_cache' ) ) {
            wp_schedule_event(
                time() + DAY_IN_SECONDS,
                'weekly',
                'ipv_vendor_clear_cache'
            );
        }

        // Schedule pulizia log settimanale
        if ( ! wp_next_scheduled( 'ipv_vendor_cleanup_logs' ) ) {
            wp_schedule_event(
                time() + DAY_IN_SECONDS + 3600, // 1 ora dopo clear_cache
                'weekly',
                'ipv_vendor_cleanup_logs'
            );
        }

        // Flush rewrite rules
        flush_rewrite_rules();

        // Set activation flag
        update_option( 'ipv_vendor_activated', time() );
        up
Cercando il gestore del reset dei crediti
Ho trovato un hook chiamato "ipv_vendor_reset_credits". Ora devo cercare il gestore relativo a questo hook per capire come viene gestito il reset dei crediti. Prover√≤ a localizzare il codice che gestisce questo processo.

Trovare gestore per 'ipv_vendor_reset_credits'
idx=vc.find('ipv_vendor_reset_credits')
print(vc[idx-300:idx+600])

rtal::instance();

        // REST API
        add_action( 'rest_api_init', [ $this, 'register_rest_routes' ] );

        // Backward compatibility: legacy admin page slug
        add_action( 'admin_init', [ $this, 'maybe_redirect_legacy_admin_pages' ] );

        // Cron hooks
        add_action( 'ipv_vendor_reset_credits', [ $this, 'reset_monthly_credits' ] );
        add_action( 'ipv_vendor_clear_cache', [ 'IPV_Vendor_API_Gateway', 'clear_old_cache' ] );
        add_action( 'ipv_vendor_cleanup_logs', [ $this, 'cleanup_old_logs' ] );

        // Admin enqueue
        add_action( 'admin_enqueue_scripts', [ $this, 'admin_enqueue_scripts' ] );

        // Health check endpoint (non autenticato per monitoring)
        add_action( 'rest_api_init', [ $this, 'register_health_endpoint' ] );
    }

    /**
     * Backward compatibility for older bookmarks/links.
     * Some older builds used ad
Individuando il metodo reset_monthly_credits
Ho trovato che esiste un metodo chiamato "reset_monthly_credits" nel modulo vendor-core. Ora bisogna localizzarlo per vedere come viene implementato. Probabilmente contiene la logica per il reset dei crediti mensili, quindi dovrei esaminare la sua implementazione per capire meglio cosa sta facendo.

Localizzando il metodo reset_monthly_credits
m=re.search(r'function reset_monthly_credits\(\).*?\{', vc, re.S)
print(vc[m.start():m.start()+1400])

function reset_monthly_credits() {
        $count = IPV_Vendor_Credits_Manager::reset_all_credits();
        error_log( sprintf( 'IPV Vendor Cron: Reset mensile completato - %d licenze', $count ) );
    }

    /**
     * Cleanup old API logs (keep 90 days)
     */
    public function cleanup_old_logs() {
        global $wpdb;
        
        $deleted = $wpdb->query(
            "DELETE FROM {$wpdb->prefix}ipv_api_logs
            WHERE created_at < DATE_SUB(NOW(), INTERVAL 90 DAY)"
        );

        if ( $deleted > 0 ) {
            error_log( sprintf( 'IPV Vendor Cron: Rimossi %d log vecchi', $deleted ) );
        }
    }

    public function admin_enqueue_scripts( $hook ) {
        // Only on IPV Vendor pages
        if ( strpos( $hook, 'ipv-vendor' ) === false ) {
            return;
        }

        wp_enqueue_style(
            'ipv-vendor-admin',
            IPV_VENDOR_URL . 'admin/assets/css/admin.css',
            [],
            IPV_VENDOR_VERSION
        );

        wp_enqueue_script(
            'ipv-vendor-admin',
            IPV_VENDOR_URL . 'admin/assets/js/admin.js',
            [ 'jquery' ],
            IPV_VENDOR_VERSION,
            true
        );

        wp_localize_script( 'ipv-vendor-admin', 'ipvVendor', [
            'ajaxUrl' => admin_url( 'admin-ajax.php' ),
            'nonce' => wp_create_nonce( 'ipv_vendor_admin' ),
            'restUrl' => res
Esaminando reset_all_credits nel gestore dei crediti
Ho trovato una funzione statica chiamata "reset_all_credits" nel gestore dei crediti. Ora devo dare un'occhiata a come √® implementata per capire meglio il suo ruolo e se √® legata al reset dei crediti mensili o a un altro tipo di reset.

Ispezionando la funzione reset_all_credits
txt=read(credits_path)
m=re.search(r'static function reset_all_credits\(\)', txt)
print(txt[m.start():m.start()+1600])

static function reset_all_credits() {
        global $wpdb;

        // Get all licenses that need reset
        $licenses = $wpdb->get_results(
            "SELECT * FROM {$wpdb->prefix}ipv_licenses
            WHERE status = 'active'
            AND credits_reset_date <= CURDATE()"
        );

        $manager = self::instance();
        $count = 0;

        foreach ( $licenses as $license ) {
            if ( $manager->reset_license_credits( $license->id ) ) {
                $count++;
            }
        }

        error_log( sprintf(
            'IPV Vendor: Monthly credits reset completed - %d licenses reset',
            $count
        ));

        return $count;
    }

    /**
     * Check if WooCommerce subscription is active
     */
    private function is_subscription_active( $order_id, $product_id ) {
        // Get product to check if it's a subscription
        $product = wc_get_product( $product_id );
        if ( ! $product ) {
            return false;
        }

        // If not a subscription product, check expiry date
        if ( ! $product->is_type( 'subscription' ) ) {
            return true; // One-time purchase, expiry handled separately
        }

        // Check WooCommerce Subscriptions
        if ( ! function_exists( 'wcs_order_contains_subscription' ) ) {
            return true; // Subscriptions not installed
        }

        if ( ! wcs_order_contains_subscription( $order_id ) ) {
            return true; // Not a subscription order
        }

        $subscriptions = wcs_get_subscriptions_for_order( $order_id );

        foreach ( $sub
Modificando la logica di reset_license_credits
Ho trovato la logica di reset in reset_license_credits, ma devo modificarla per preservare i crediti extra. L‚Äôidea √® di fare in modo che la funzione resetti solo l'allocazione mensile senza intaccare i crediti extra. Ora devo individuare il punto specifico del codice dove avviene questa operazione.

Localizzando la funzione reset_license_credits
m=re.search(r'function reset_license_credits\(', txt)
print(txt[m.start():m.start()+1400])

function reset_license_credits( $license_id ) {
        global $wpdb;

        $license = $wpdb->get_row( $wpdb->prepare(
            "SELECT * FROM {$wpdb->prefix}ipv_licenses WHERE id = %d",
            $license_id
        ));

        if ( ! $license ) {
            return false;
        }

        // Check if subscription is still active via WooCommerce
        if ( ! $this->is_subscription_active( $license->order_id, $license->product_id ) ) {
            // Subscription cancelled/expired - don't reset, mark as cancelled
            $wpdb->update(
                $wpdb->prefix . 'ipv_licenses',
                [ 'status' => 'cancelled' ],
                [ 'id' => $license_id ],
                [ '%s' ],
                [ '%d' ]
            );

            error_log( sprintf(
                'IPV Vendor: License %s NOT reset - subscription inactive',
                $license->license_key
            ));

            return false;
        }

        // Reset credits
        $wpdb->update(
            $wpdb->prefix . 'ipv_licenses',
            [
                'credits_remaining' => $license->credits_total,
                'credits_reset_date' => date( 'Y-m-01', strtotime( '+1 month' ) )
            ],
            [ 'id' => $license_id ],
            [ '%d', '%s' ],
            [ '%d' ]
        );

        // Send email notification
        $this->send_credits_reset_email(
Modificando la logica di reset per includere nuovi dati
La funzione di reset attuale sovrascrive credits_remaining con credits_total, ma dobbiamo aggiungere credits_extra e credits_used_month. Verranno introdotti nuovi campi nelle tabelle e una nuova tabella. Il requisito dell'utente sembra orientato su una pagina Admin, quindi sarebbe meglio estendere la pagina esistente ‚ÄúLicenze‚Äù invece di crearne una nuova.

Decidere sulla struttura della pagina Admin
Posso mantenere la nostra nuova pagina o agganciarla al menu esistente. La soluzione pi√π semplice potrebbe essere aggiungere una nuova voce "Licenze Avanzate" al menu "ipv-vendor-dashboard", ma dovrei sostituire la pagina esistente o migliorarla con la nostra funzionalit√†. Modificare "render_licenses" sembra la soluzione pi√π pratica.

Pianificare l‚Äôintegrazione con il menu Admin
Un modo sarebbe creare le nuove pagine e usare un filtro per associare il renderer alla voce "ipv-vendor-licenses". Modifico render_licenses per usare il nuovo renderer, che includer√† funzionalit√† avanzate come ricerca e ledger. Aggiunger√≤ anche l‚Äôinstallazione del DB per le nuove tabelle e colonne.

Verificando l'auto-installazione con l'attivazione del plugin
Il modulo del plugin sembra gi√† avere un hook di attivazione per la creazione delle tabelle. Devo controllare il file principale, ipv-pro-vendor.php, per verificarlo. Cos√¨ posso integrare le modifiche necessarie senza introdurre conflitti, usando l'auto-installazione esistente.

Implementing advanced Licenze page with ledger and export
main=read(os.path.join(base,'ipv-pro-vendor.php'))
print(main[:500])

<?php
/**
 * Plugin Name: IPV Pro Vendor System
 * Plugin URI: https://ipv-production-system.com
 * Description: Sistema completo per vendere IPV Pro Plugin via WooCommerce con API Gateway integrato
 * Version: 1.4.0-optimized
 * Author: IPV Team
 * Author URI: https://ipv-production-system.com
 * Requires at least: 6.0
 * Requires PHP: 8.0
 * WC requires at least: 8.0
 * WC tested up to: 9.5
 * Text Domain: ipv-pro-vendor
 * Domain Path: /languages
 * License: GPL v2 or later
 *
 * CHANGELOG v1
Aggiornare la versione e controllare l'hook di attivazione
Devo aggiornare la versione del plugin a 1.4.1. Inoltre, √® importante verificare l'hook di attivazione per assicurarmi che tutto funzioni correttamente durante l'installazione e la configurazione del plugin. Cos√¨ sar√≤ certo che venga eseguito come previsto.

Verifica hook di attivazione e aggiornamento
for pat in ['register_activation_hook','Auto_Installer','ipv_vendor_installed']:
    print(pat, main.count(pat))

register_activation_hook 1
Auto_Installer 2
ipv_vendor_installed 0
Verificando hook di attivazione e aggiornamenti
idx=main.find('register_activation_hook')
print(main[idx:idx+600])

register_activation_hook( __FILE__, function() {
    if ( ! class_exists( 'WooCommerce' ) ) {
        deactivate_plugins( plugin_basename( __FILE__ ) );
        wp_die( 'IPV Pro Vendor richiede WooCommerce. Installa e attiva WooCommerce prima di attivare questo plugin.' );
    }

    // v1.4.0 - Auto-installer (database tables, defaults, CRON)
    IPV_Pro_Vendor_Auto_Installer::install();

    // v1.3.3 - Auto-configurazione sistema
    require_once IPV_VENDOR_DIR . 'includes/class-auto-configurator.php';
    $auto_config = IPV_Vendor_Auto_Configurator::instance();
    $auto_config->activate()
Implementing database updates and cooldown logic
L'auto-installer esegue gi√† la creazione delle tabelle. Estenderemo questo processo per aggiungere nuove colonne e la tabella ipv_credit_ledger creando una classe DB che verr√† chiamata nell'hook di attivazione. Aggiungeremo anche logica per il "cooldown" di 7 giorni, visualizzando le date sul dettaglio della licenza.

Aggiornamento hook attivazione e gestione crediti
cp=read(os.path.join(base,'includes','class-customer-portal.php'))
print(cp[:800])

<?php
/**
 * IPV Customer Portal
 *
 * Interfaccia frontend per i clienti (My Account extensions)
 */

if ( ! defined( 'ABSPATH' ) ) exit;

class IPV_Vendor_Customer_Portal {

    private static $instance = null;

    public static function instance() {
        if ( null === self::$instance ) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    private function __construct() {
        // Add license tab to My Account
        add_filter( 'woocommerce_account_menu_items', [ $this, 'add_license_menu_item' ] );
        add_action( 'init', [ $this, 'add_endpoints' ] );
        add_action( 'woocommerce_account_ipv-licenses_endpoint', [ $this, 'render_licenses_page' ] );

        // Dashboard widget
        add_action( 'woocommerce_account_dashboard', [
Enhancing customer portal with credit purchase flow
Il portale cliente estende gi√† "My Account" con l'endpoint ipv-licenses, quindi possiamo usarlo per mostrare e acquistare crediti. Modificheremo la class per aggiungere un item di menu e un endpoint ipv-credits. Ogni acquisto sar√† collegato alla chiave di licenza, e la memorizzeremo in ordine e articoli del carrello.

Implementing credits table and features
Per soddisfare le richieste, creer√≤ prima il tavolo ipv_credit_ledger con dbDelta all'attivazione. Aggiunger√≤ i campi site_url e site_unlock_at per le caratteristiche di blocco, concentrandomi su una funzionalit√† di base. Aggiunger√≤ anche il supporto alla separazione dei crediti extra e alla loro persistenza per un utilizzo corretto.

Implementing credits logic and DB updates
Per implementare correttamente la gestione dei crediti, imposter√≤ credits_remaining per includere credits_total e credits_extra, con l'aggiornamento dinamico di credits_used_month. Cambier√≤ il codice esistente per preservare la parte extra e garantir√≤ che il reset mantenga l'extra. Inoltre, aggiorner√≤ il DB per includere colonne aggiuntive.

Fixing credit consumption logic
In the update for Credits Manager, I‚Äôll adjust the SQL to increment credits_used_month and calculate credits_remaining correctly. The remaining credits should be calculated based on the total pool and extra credits, while ensuring unused extra is preserved. I‚Äôll also modify the reset logic to prevent extra credits from being re-granted each month.

Refining credit consumption tracking
We need a more accurate way to track credit consumption. By adding columns for credits_monthly_remaining and credits_extra_remaining, I'll calculate the remaining credits by combining both. On consumption, I'll decrement credits_monthly first. This method simplifies the process while keeping compatibility with the old structure.

Let's make sure the new columns are added and the system reflects these changes.

Optimizing credit updates and ledger
To minimize SQL queries, we‚Äôll perform a single update query using CASE to adjust credits_monthly and credits_extra. The remaining credits will be recalculated based on the updated values. For credit additions, the query will update both credits_extra and credits_remaining. I'll also set up a ledger, metabox, and implement export features as needed.

Creating plugin modifications for advanced licensing
I‚Äôll implement the requested modifications by updating the plugin folder, version number, and zipping the file as "ipv-vendor-1.4.1.zip". For the admin interface, I‚Äôll integrate a new "Advanced" section within render_licenses without overriding existing code. We‚Äôll ensure proper inclusion of new files with require_once.

Implementando gestione e acquisto crediti IPV
req_lines=[line for line in main.splitlines() if 'require_once' in line or 'require' in line]
req_lines[:40], len(req_lines)

([' * WC requires at least: 8.0',
  "require_once IPV_VENDOR_DIR . 'includes/class-auto-configurator.php';",
  "require_once IPV_VENDOR_DIR . 'includes/class-auto-installer.php';",
  "require_once IPV_VENDOR_DIR . 'includes/class-setup-wizard.php';",
  '            require_once $path;',
  "require_once IPV_VENDOR_DIR . 'includes/class-vendor-core.php';",
  "    require_once IPV_VENDOR_DIR . 'includes/class-auto-configurator.php';",
  "    require_once IPV_VENDOR_DIR . 'includes/class-vendor-core.php';",
  "    require_once plugin_dir_path( __FILE__ ) . 'includes/class-auto-installer.php';",
  "require_once IPV_VENDOR_DIR . 'includes/class-admin-status-page.php';"],
 10)
Inspecting loading includes
I think there‚Äôs a loader that includes other files, possibly using an array. I‚Äôll need to inspect the section responsible for loading these files to understand how everything is being included. This will help me ensure that the new files are properly included in the process without any issues.

Ispezionando sezione di caricamento delle inclusioni
idx=main.find('Load required classes')
print(main[idx-200:idx+900])


Cercando "required_classes"
Devo cercare ‚Äúrequired_classes‚Äù per verificare se ci sono classi o file di riferimento che devono essere inclusi nel processo. Questo mi aiuter√† a identificare le dipendenze necessarie e assicurarmi che tutto venga caricato correttamente nel contesto.

Ricerca di "required_classes" nel testo
import re
m=re.search(r'\$required_classes\s*=\s*\[', main)
print(main[m.start():m.start()+700])

---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Cell In[50], line 3
      1 import re
      2 m=re.search(r'\$required_classes\s*=\s*\[', main)
----> 3 print(main[m.start():m.start()+700])

AttributeError: 'NoneType' object has no attribute 'start'
Esplorando le inclusioni richieste
Devo esaminare meglio le parti del codice dove vengono richiesti "includes", come le classi o i core vendor. Questo mi aiuter√† a capire come vengono caricate le risorse necessarie e se ci sono dipendenze cruciali che devono essere gestite in modo corretto.

Aprendo codice relativo a classi e vendor
print(main[500:1500])

.3.18 (2025-12-11):
 * - FIX CRITICO: Compatibilit√† PHP 8.x - Risolti deprecation warnings
 *   - Fix: strpos() e str_replace() ricevevano null invece di string
 *   - Aggiunto type-safe casting per tutti i get_post_meta()
 *   - class-woocommerce-integration.php: Validazione crediti e activation limit
 *   - class-license-manager.php: Safe casting per variant_slug, credits, activation
 *   - class-plans-manager.php: Protezione display prodotti WooCommerce
 *   - Eliminati PHP Deprecated warnings nel log
 *   - Compatibilit√† totale con PHP 8.0, 8.1, 8.2, 8.3
 *
 * CHANGELOG v1.3.17 (2025-12-11):
 * - FIX CRITICO: Descrizioni prodotti WooCommerce corrotte
 *   - Nuovo metodo emoji_to_html_entities() in class-plans-manager.php
 *   - Converti emoji Unicode in HTML entities (compatibile UTF8)
 *   - Descrizioni prodotti ora strutturate in 4 sezioni
 *   - Fix: emoji üé¨üìäüöÄ ora renderizzate correttamente
 *
 * CHANGELOG v1.3.11:
 * - PERFORMANCE: Ottimizzato polling SupaData
 *   - Intervallo
Esplorando costanti e inclusioni
Devo cercare le definizioni delle costanti e degli "includes". Capire dove sono definite le costanti mi aiuter√† a comprendere meglio la configurazione del sistema, mentre monitorare gli "includes" √® cruciale per assicurarmi che tutte le risorse necessarie vengano caricate correttamente nel flusso di esecuzione.

Cercando costanti definite e inclusioni
for pat in ['define(', 'IPV_VENDOR_DIR', 'includes/']:
    if pat in main:
        pass
idx=main.find('define( \'IPV_VENDOR_DIR\'')
print(main[idx:idx+600])

define( 'IPV_VENDOR_DIR', plugin_dir_path( __FILE__ ) );
define( 'IPV_VENDOR_URL', plugin_dir_url( __FILE__ ) );

// Load Auto-Configurator (must be loaded before autoloader)
require_once IPV_VENDOR_DIR . 'includes/class-auto-configurator.php';

// Load Auto-Installer and Setup Wizard
require_once IPV_VENDOR_DIR . 'includes/class-auto-installer.php';
require_once IPV_VENDOR_DIR . 'includes/class-setup-wizard.php';

// Check WooCommerce
add_action( 'admin_init', 'ipv_vendor_check_woocommerce' );
function ipv_vendor_check_woocommerce() {
    if ( ! class_exists( 'WooCommerce' ) ) {
        add_a
Indagando sulla funzione di autoload
C‚Äô√® un autoloader da considerare, quindi devo localizzare la funzione ipv_vendor_autoload. Questa funzione potrebbe essere responsabile dell'automazione del caricamento delle classi o dei file, quindi √® importante capire come funziona per ottimizzare l'integrazione e assicurarmi che le risorse vengano caricate correttamente.

Localizzando la funzione ipv_vendor_autoload
m=re.search(r'function\s+ipv_vendor_autoload', main)
print(main[m.start():m.start()+800])

---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Cell In[53], line 2
      1 m=re.search(r'function\s+ipv_vendor_autoload', main)
----> 2 print(main[m.start():m.start()+800])

AttributeError: 'NoneType' object has no attribute 'start'
Verificando spl_autoload_register
Forse viene utilizzato spl_autoload_register con una chiusura. Quindi incider√≤ una ricerca su questa funzione, per capire come viene usata. Se √® configurata con una chiusura, serve per caricare automaticamente le classi, quindi voglio assicurarmi che non ci siano errori nella logica di autoloading.

Ricerca di spl_autoload_register nel codice
idx=main.find('spl_autoload_register')
print(idx)
print(main[idx:idx+700])

2670
spl_autoload_register( function( $class ) {
    if ( strpos( $class, 'IPV_Vendor_' ) === 0 ) {
        $file = strtolower( str_replace( ['IPV_Vendor_', '_'], ['', '-'], $class ) );
        $path = IPV_VENDOR_DIR . 'includes/class-' . $file . '.php';
        if ( file_exists( $path ) ) {
            require_once $path;
        }
    }
});

// Load core
require_once IPV_VENDOR_DIR . 'includes/class-vendor-core.php';

// Init
add_action( 'plugins_loaded', function() {
    if ( class_exists( 'WooCommerce' ) ) {
        IPV_Vendor_Core::instance();

        // Initialize Setup Wizard
        if ( is_admin() ) {
            IPV_Pro_Vendor_Setup_Wizard::init();
        }
    }
});

// Activation
re
Pianificando la struttura del caricamento automatico
L'autoloader carica le classi nel formato IPV_Vendor_X da includes/class-x.php. Per la nostra nuova classe, possiamo usare il formato IPV_Vendor_DB e creare includes/class-db.php. Per le azioni amministrative, utilizzeremo includes/class-admin-actions.php. Per le tabelle, che estendono WP_List_Table, le aggiungeremo nella cartella admin, ma le caricheremo solo quando richieste.

Pianificando la struttura delle classi amministrative
Aggiunger√≤ includes/class-admin-actions.php con azioni per admin_post, blocco del sito ed esportazione. La funzionalit√† di esportazione sar√† separata in includes/class-admin-export.php. Aggiunger√≤ anche includes/class-order-metabox.php per la gestione dei metabox. Per la dashboard, modificher√≤ class-admin-dashboard.php per includere il renderer e visualizzare le licenze. Per l'inizializzazione delle classi, utilizzer√≤ init_hooks per semplificare la configurazione, implementando uno stile singleton.

Implementazione del cooldown e aggiornamento del database
Ho deciso di implementare la funzione site_unlock_cooldown_days() direttamente in IPV_Vendor_Core come metodo statico, che restituisce 7 per il filtro. Questo semplifica la struttura, eliminando la necessit√† di un file separato per la funzione. Aggiunger√≤ anche due nuove colonne nel database (site_unlock_at e site_url) per gestire il sistema di sblocco.

Aggiunta di nuove colonne e migrazione dei dati
Utilizzer√≤ site_url nella tabella delle licenze per il sistema di blocco, aggiungendo le colonne credits_monthly e credits_extra per gestire la divisione dei crediti. Durante l'installazione, mi assicuro che le colonne vengano create e i dati migrati correttamente, mantenendo l'integrit√† dei crediti.

Gestire i crediti extra e l'aggiornamento del reset
Quando si esegue il reset, la colonna monthly ottiene l'intero credits_total, ma extra rimane zero. Per le future acquisti, extra aumenter√†. Dobbiamo aggiornare il metodo reset_license_credits per gestire correttamente credits_monthly e credits_extra, e poi fare in modo che venga mostrato in get_credits_info.

Pianificazione modifiche plugin e gestione crediti
wci=read(os.path.join(base,'includes','class-woocommerce-integration.php'))
'IPV-CREDITS-EXTRA' in wci, wci.count('credits')

(False, 19)
Decidendo sulle funzionalit√† extra per i crediti
Anche se non richiesto esplicitamente ora, penso che sia comunque utile includere la funzionalit√† di acquisto di crediti extra, che potrebbe essere gestita tramite il setup wizard. Prima, esplorer√≤ il file includes/class-setup-wizard.php per vedere se gi√† gestisce la creazione di prodotti, in quanto potrebbe essere utile.

Ispezionando la classe del wizard di configurazione
sw=read(os.path.join(base,'includes','class-setup-wizard.php'))
print(sw[:700])

<?php
/**
 * Setup Wizard for IPV Pro Vendor Server
 *
 * Interactive installation wizard with step-by-step configuration
 *
 * @package IPV_Pro_Vendor
 * @version 1.4.0-optimized
 */

if (!defined('ABSPATH')) {
    exit;
}

class IPV_Pro_Vendor_Setup_Wizard {

    /**
     * Initialize wizard
     */
    public static function init() {
        add_action('admin_menu', array(__CLASS__, 'add_wizard_page'));
        add_action('admin_init', array(__CLASS__, 'redirect_to_wizard'));
        add_action('admin_post_ipv_vendor_save_settings', array(__CLASS__, 'save_settings'));
        add_action('admin_enqueue_scripts', array(__CLASS__, 'enqueue_assets'));
    }

    /**
     * Redirect to wizard 
Verifica della creazione dei prodotti nel plugin
Ora voglio verificare se la creazione dei prodotti √® gestita dal gestore dei piani o dal wizard di configurazione. Probabilmente quest'ultimo si concentra solo sulle impostazioni del fornitore, quindi far√≤ una ricerca in tutti i file usando "create_product" per capire meglio qual √® la gestione effettiva della creazione dei prodotti.

Cercando file con "create_product"
create_files=find_in_files(base,'wp_insert_post')
create_files[:10], len(create_files)

([], 0)
Cercando la creazione dei prodotti
Adesso voglio cercare "wc_create" per capire se questa funzione √® collegata alla creazione dei prodotti all'interno del plugin. √à un passo utile per determinare dove e come vengono creati i prodotti, cos√¨ da capire meglio quali parti del codice gestiscono questa funzionalit√†.

Cercando "wc_create" nei file
create_files=find_in_files(base,'wc_get_product_id_by_sku')
create_files, len(create_files)

([], 0)
Ricerca SKU nel codice
Adesso penso di cercare "SKU" nel codice. Potrebbe essere utile per vedere se viene usato qualcosa riguardo alla gestione dei prodotti o ad altre operazioni di creazione, lettura, aggiornamento o eliminazione (CRUD). √à un passo per identificare eventuali relazioni con le funzionalit√† del prodotto.

Ricerca SKU nel file
find_in_files(base,'SKU')

[]
Ricerca per "create products"
Penso che questo plugin potrebbe non essere ancora configurato per creare prodotti, ma in passato hanno chiesto di mantenere un wizard per farlo. Potrebbe trovarsi nel gestore dei piani. Per avere conferma, far√≤ una ricerca per la frase "create products" nel codice e vediamo cosa trovo.

Cercando testo "crea prodotti" nel codice
find_in_files(base,'crea prod')

[]
Esplorando creazione di prodotti
Ok, non sembra che ci sia un wizard di creazione prodotti presente. Forse dovremmo implementarlo noi stessi, ma √® un po' impegnativo. D'altra parte, l'utente ha chiesto di mantenere il wizard. Magari il gestore dei piani esistente ha gi√† una funzione per creare prodotti. Far√≤ una ricerca per "wc_create_product" e terminologie simili.

Cercando classi WC_Product nel codice
find_in_files(base,'WC_Product')

['/tmp/tmpcf8h9xg3/ipv-pro-vendor-optimized/includes/class-plans-manager.php']
Cercando creazione prodotto in WC_Product
pm=read(os.path.join(base,'includes','class-plans-manager.php'))
idx=pm.find('WC_Product')
print(pm[idx-200:idx+900])

       $is_subscription = in_array( $plan['price_period'], [ 'month', 'year', 'week' ] );
        
        // Use simple product (or subscription if WC Subscriptions is active)
        $product = new WC_Product_Simple();

        // Basic info
        $product->set_name( 'IPV Pro - ' . $plan['name'] );
        $product->set_slug( 'ipv-pro-' . $plan['slug'] );
        $product->set_status( 'publish' );
        $product->set_catalog_visibility( 'visible' );
        $product->set_description( $this->generate_product_description( $plan ) );
        $product->set_short_description( $plan['description'] ?? '' );

        // Price
        $product->set_regular_price( $plan['price'] );
        
        // Virtual & Downloadable
        $product->set_virtual( true );
        $product->set_downloadable( true );

        // Add download file if plugin is uploaded
        $plugin_info = $this->get_plugin_download_info();
        if ( $plugin_info ) {
            $upload_dir = wp_upload_dir();
            $download_url = $upload_dir['baseurl'] . '/ipv-downloads/' . $plugin_info['filename'];
     
Raffinando la creazione del prodotto di crediti extra
Il gestore dei piani crea i prodotti come WC_Product_Simple, anche per gli abbonamenti, forse utilizzando la classe delle sottoscrizioni, ma non del tutto. Potremmo inserire la creazione del prodotto crediti extra nel gestore piani o nel wizard admin. Per√≤, considerando la richiesta, lasciamo la creazione invariata per ora e aggiungiamo il prodotto in un passo futuro, magari nell'interfaccia di amministrazione con un pulsante semplice.

Implementazione del prodotto crediti extra e integrazione
Anche se il wizard esistente potrebbe gi√† gestire la creazione dei prodotti, aggiungeremo il prodotto crediti extra e la funzione di acquisto nell'area clienti. All‚Äôinterno del portale, aggiungeremo una voce di menu "IPV Credits" che crea o trova il prodotto tramite SKU. Inoltre, implementeremo l'integrazione con WooCommerce per aggiornare i crediti quando l'ordine √® completo, salvando anche la chiave della licenza.

Semplificazione della gestione dei crediti extra e validazione licenza
Quando aggiungiamo i crediti extra al carrello dalla sezione "Il mio account", aggiungiamo il prodotto e impostiamo la chiave di licenza come variabile di sessione o nei dati dell'articolo del carrello. Dobbiamo aggiornare lo schema del database e la logica per le funzionalit√† di blocco del sito usando la tabella attivazioni e l'endpoint API esistente.

Implementing extra credits product and license management
ge=read(os.path.join(base,'api','endpoints','class-gateway-endpoints.php'))
print(ge[:900])

<?php
/**
 * IPV Gateway REST API Endpoints
 *
 * API Gateway che protegge le chiamate a SupaData, OpenAI, YouTube
 * Tutte le API keys sono sul server, il client non le vede mai!
 */

if ( ! defined( 'ABSPATH' ) ) exit;

class IPV_Vendor_Gateway_Endpoints {

    public function register_routes() {
        // POST /wp-json/ipv-vendor/v1/transcript
        register_rest_route( 'ipv-vendor/v1', '/transcript', [
            'methods' => 'POST',
            'callback' => [ $this, 'get_transcript' ],
            'permission_callback' => '__return_true'
        ]);

        // POST /wp-json/ipv-vendor/v1/description
        register_rest_route( 'ipv-vendor/v1', '/description', [
            'methods' => 'POST',
            'callback' => [ $this, 'generate_description' ],
            'permission_callback' => '__return_true'
        ]);

        // GET /wp-json/ipv-vendor/v1/credits
        regi
Cercando la validazione della licenza
Devo cercare dove viene gestita la validazione della licenza nel sistema. Probabilmente si trova in una funzione o classe che verifica lo stato della licenza e la sua attivazione. Esaminer√≤ i punti di controllo relativi alla validazione per essere sicuro di aggiornare correttamente il processo.

Cercando validazione licenza
idx=ge.find('validate_license')
idx

5064
Validazione della licenza
print(ge[idx-200:idx+900])

ey trovata: ' . substr( $license_key, 0, 8 ) . '...' . substr( $license_key, -4 ) );
        }

        $license_manager = IPV_Vendor_License_Manager::instance();
        $license = $license_manager->validate_license( $license_key );

        if ( is_wp_error( $license ) ) {
            return $license;
        }

        return $license;
    }

    /**
     * POST /transcript
     * Get video transcript via SupaData (server-side API call)
     */
    public function get_transcript( $request ) {
        // v1.3.6 - Enhanced logging
        if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
            error_log( '=== GET_TRANSCRIPT START ===' );
        }

        // Validate license
        $license = $this->validate_request_license( $request );

        if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
            error_log( 'validate_request_license returned: ' . ( is_wp_error( $license ) ? 'WP_Error' : 'License Object' ) );
            if ( is_wp_error( $license ) ) {
                error_log( 'WP_Error code: ' . $license->get_error_code() );
                error_log( 'WP_Error message: ' . $
Ispezionare la funzione di validazione della licenza
Penso che la funzione validate_request_license utilizzi il metodo validate_license del gestore delle licenze (license manager), che probabilmente verifica lo stato della licenza e le attivazioni. Devo controllare il codice del metodo validate_license per comprendere meglio come gestisce questo processo.

Ispezionando la funzione validate_license del gestore licenze
lm=read(os.path.join(base,'includes','class-license-manager.php'))
m=re.search(r'function validate_license\(', lm)
print(lm[m.start():m.start()+1700])

function validate_license( $license_key, $site_url = '' ) {
        global $wpdb;

        // v1.3.4 - Enhanced debug logging
        if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
            error_log( '=== LICENSE VALIDATION START ===' );
            error_log( 'License Key: ' . $license_key );
            error_log( 'Site URL: ' . $site_url );
        }

        $license = $wpdb->get_row( $wpdb->prepare(
            "SELECT * FROM {$wpdb->prefix}ipv_licenses WHERE license_key = %s",
            $license_key
        ));

        if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
            error_log( 'License found in DB: ' . ( $license ? 'YES' : 'NO' ) );
            if ( $license ) {
                error_log( 'License status: ' . $license->status );
                error_log( 'License expires_at: ' . ( $license->expires_at ?? 'NULL' ) );
                error_log( 'License activation_limit: ' . ( $license->activation_limit ?? 'NULL' ) );
            }
        }

        if ( ! $license ) {
            if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
                error_log( '‚ùå VALIDATION FAILED: License key not found in database' );
            }
            return new WP_Error( 'invalid_license', 'License key non valida' );
        }

        // Check status
        if ( 'active' !== $license->status ) {
            if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
                error_log( '‚ùå VALIDATION FAILED: License status is not active: ' . $license->status );
            }
            return new WP_Error( 'inactive_license', 'License non attiva. Status: ' . $license->status );
        }

        // Check expiry
        if ( $license->expires_at && strtotime( $license->expires_at 
Recuperando il limite di attivazione
idx=lm.find('activation_limit')
print(lm[idx-200:idx+900])

uct_id, '_ipv_credits_total', true );
        $credits_total = ( $credits_raw !== '' && $credits_raw !== null ) ? (int) $credits_raw : 10;

        $activation_raw = get_post_meta( $product_id, '_ipv_activation_limit', true );
        $activation_limit = ( $activation_raw !== '' && $activation_raw !== null ) ? (int) $activation_raw : 1;

        // Calculate expiry for one-time purchases
        $expires_at = null;
        if ( ! $product->is_type( 'subscription' ) ) {
            // One-time = 1 year
            $expires_at = date( 'Y-m-d H:i:s', strtotime( '+1 year' ) );
        }

        // Generate license
        $license_key = $this->generate_license_key();

        // Calculate next reset date (first day of next month)
        $credits_reset_date = date( 'Y-m-01', strtotime( '+1 month' ) );

        // Insert license
        $inserted = $wpdb->insert(
            $wpdb->prefix . 'ipv_licenses',
            [
                'license_key' => $license_key,
                'order_id' => $order_id,
                'product_id' => $product_id,
                'user_id' => $order->
Controllare la validazione della licenza per attivazioni
Probabilmente la verifica dell'attivazione o del limite avviene pi√π in basso nel metodo validate_license. Continuer√≤ a esaminare il codice per verificare come gestisce le attivazioni e se ci sono controlli dopo la scadenza della licenza.

Verificando utilizzo attivazione licenza
# locate activation_count usage
for p in ['activation_count','ipv_license_activations','site_url']:
    print(p, lm.count(p))

activation_count 2
ipv_license_activations 0
site_url 23
Verifica dell'uso di site_url in validate_license
validate_license utilizza il parametro site_url, ma potrebbe non fare riferimento alla tabella delle attivazioni. Ora cercher√≤ nel codice di validate_license per capire esattamente come viene trattato site_url e se ci sono riferimenti alle attivazioni in questo contesto.

Cercando utilizzo di site_url nella funzione validate_license
start=m.start()
end=lm.find('function create_license_from_order')
segment=lm[start:end]
# show part where site_url used
pos=segment.find('site_url')
print(segment[pos-200:pos+1200])


Verifica della posizione negativa
Oh, sembra che ci sia un errore con il pos -1, forse √® un problema legato a una posizione errata. Posso cercare meglio all'interno di un segmento per capire dove si trova veramente quella posizione e fare la correzione necessaria.

Trovare posizione di site_url nel segmento
import re
for mm in re.finditer(r'site_url', segment):
    print(mm.start())

Verifica del sito URL nella funzione validate_license
Ooops, sembra che non ci sia il parametro 'site_url' nella funzione validate_license. Per√≤, aspetta, nei log di debug precedenti √® apparso "Site URL". Forse ho estratto qualcosa di sbagliato. Provo a estrarre l'intera funzione validate_license e fare una ricerca pi√π approfondita.

Estrazione corpo funzione validate_license
# extract function body by naive braces matching
def extract_function(text, name):
    idx=text.find(f'function {name}')
    if idx==-1: return None
    brace=text.find('{', idx)
    depth=0
    for i in range(brace, len(text)):
        if text[i]=='{': depth+=1
        elif text[i]=='}':
            depth-=1
            if depth==0:
                return text[idx:i+1]
    return text[idx:]
val=extract_function(lm,'validate_license')
len(val), 'site_url' in val, val[:400]

(4661,
 True,
 "function validate_license( $license_key, $site_url = '' ) {\n        global $wpdb;\n\n        // v1.3.4 - Enhanced debug logging\n        if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {\n            error_log( '=== LICENSE VALIDATION START ===' );\n            error_log( 'License Key: ' . $license_key );\n            error_log( 'Site URL: ' . $site_url );\n        }\n\n        $license = $wpdb->get_row( $wpdb->p")
Verifica dell'uso di 'site_url' nella funzione
Sembra che ci sia 'site_url', ma √® troncato con i puntini di sospensione? Pu√≤ darsi che la funzione includa " ...l );", probabilmente a causa dei puntini inseriti prima. Voglio comunque stampare la porzione successiva dove viene effettivamente usato 'site_url' per chiarire.

Visualizzando porzioni con 'site_url'
# find all lines containing site_url
lines=[l for l in val.splitlines() if 'site_url' in l]
lines[:50], len(lines)

(["function validate_license( $license_key, $site_url = '' ) {",
  "            error_log( 'Site URL: ' . $site_url );",
  '        // v1.3.4 - SKIP activation check if site_url is empty (for API calls)',
  '        if ( empty( $site_url ) ) {',
  "                error_log( '‚úÖ VALIDATION SUCCESS: License valid (no site_url check)' );",
  '        // Check activation limit if site_url provided',
  '        if ( ! empty( $site_url ) ) {',
  "                error_log( 'Checking activation for site_url: ' . $site_url );",
  '                WHERE license_id = %d AND site_url = %s AND is_active = 1",',
  '                $site_url'],
 10)
Ispezionando la funzione con la tabella delle attivazioni
Sembra che la funzione interessante includa anche una tabella di attivazione, probabilmente 'ipv_activations'. Voglio verificare meglio ci√≤, quindi stamper√≤ quella sezione per esaminare come viene usata. Potrebbe essere la chiave per risolvere il caso.

Stampando sezione attivazioni funzione
# show around activation check
idx=val.find('SKIP activation')
print(val[idx-200:idx+1800])

ense->expires_at );
            }
            return new WP_Error( 'expired_license', 'License scaduta il ' . date_i18n( 'd/m/Y', strtotime( $license->expires_at ) ) );
        }

        // v1.3.4 - SKIP activation check if site_url is empty (for API calls)
        // This allows the license to work even without explicit activation
        if ( empty( $site_url ) ) {
            if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
                error_log( '‚úÖ VALIDATION SUCCESS: License valid (no site_url check)' );
            }
            return $license;
        }

        // Check activation limit if site_url provided
        if ( ! empty( $site_url ) ) {
            if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
                error_log( 'Checking activation for site_url: ' . $site_url );
            }

            $activation = $wpdb->get_row( $wpdb->prepare(
                "SELECT * FROM {$wpdb->prefix}ipv_activations
                WHERE license_id = %d AND site_url = %s AND is_active = 1",
                $license->id,
                $site_url
            ));

            if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
                error_log( 'Activation found: ' . ( $activation ? 'YES' : 'NO' ) );
            }

            if ( ! $activation ) {
                // Check if can activate
                $active_count = $wpdb->get_var( $wpdb->prepare(
                    "SELECT COUNT(*) FROM {$wpdb->prefix}ipv_activations
                    WHERE license_id = %d AND is_active = 1",
                    $license->id
                ));

                if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
                    error_log( 'Active count: ' . $active_count . ' / ' . $license->activation_limit );
                }

                if ( $active_count >= $license->activation_limit ) {
                    if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
                        error_log( '‚ùå VALIDATION FAILED: Activation limit reached' );
                    }
                
Esaminando la tabella ipv_activations
Quindi, la tabella corretta sembra essere ipv_activations, non ipv_license_activations. Questo spiega il funzionamento con il limite di attivazioni per sito. La tabella probabilmente memorizza l'URL del sito e gestisce il binding. Tuttavia, l'utente vuole un'opzione per sbloccare o riassociare. Esaminer√≤ lo schema della tabella ipv_activations per continuare.

Ispezionando lo schema della tabella ipv_activations
schema=read(os.path.join(base,'database-schema.sql'))
# find ipv_activations table
start=schema.find('TABLE: Activations')
print(schema[start:start+900])

TABLE: Activations
-- ====================
CREATE TABLE IF NOT EXISTS `wp_ipv_activations` (
    `id` BIGINT(20) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    `license_id` BIGINT(20) UNSIGNED NOT NULL,
    `site_url` VARCHAR(255) NOT NULL,
    `site_name` VARCHAR(255),
    `ip_address` VARCHAR(45),
    `activated_at` DATETIME DEFAULT CURRENT_TIMESTAMP,
    `last_checked_at` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    `is_active` TINYINT(1) DEFAULT 1,
    INDEX `idx_license_id` (`license_id`),
    INDEX `idx_site_url` (`site_url`),
    INDEX `idx_is_active` (`is_active`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ====================
-- TABLE: API Logs
-- ====================
CREATE TABLE IF NOT EXISTS `wp_ipv_api_logs` (
    `id` BIGINT(20) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    `license_id` BIGINT(20) UNSIGNED,
    `endpoint` VARCHAR(100
Pianificando la gestione delle attivazioni e del blocco del sito
Il binding del sito √® gi√† memorizzato nella tabella delle attivazioni. Il processo di "sbloccare/riassociare" dovrebbe operare disattivando le vecchie attivazioni o permettendo una nuova attivazione, con il limite di attivazioni a 1. Implementeremo anche il campo "site_unlock_at" nelle licenze per gestire il cooldown, semplificando la logica senza dover aggiungere il campo "site_url" alle licenze.

Implementazione sblocco, riassociare e gestione crediti
Per il processo di sblocco, disabiliteremo tutte le attivazioni per un determinato license_id per consentire una nuova attivazione. Per riassociare, disattiveremo le attivazioni precedenti e inseriremo la nuova. Il cooldown sar√† gestito tramite site_unlock_at nelle licenze. Per i crediti, aggiungeremo credits_extra per tracciare acquisti extra, mantenendo i crediti disponibili con il bilancio soggetto a reset mensile.

Gestione bilancio crediti extra e consumo
Per la gestione dei crediti extra, dovremmo diminuire credits_remaining come facciamo attualmente, ma anche tenere traccia dei crediti extra consumati. Se credits_remaining scende sotto credits_total, dovremmo decrementare correttamente credits_extra per riflettere il consumo. Tuttavia, bisogna evitare che il reset mensile ripristini i crediti extra consumati.

Organizzazione dei crediti e nuova gestione
Per semplificare, aggiungeremo due colonne per tracciare i crediti: credits_monthly_remaining e credits_extra_remaining. La gestione dei crediti decreter√† prima quelli mensili e poi gli extra. Includeremo la logica di reset per mantenere questo bilancio. Infine, aggiorner√≤ l'amministrazione per visualizzare informazioni dettagliate sulle attivazioni e lo stato di blocco.

Aggiornamento schema e gestione crediti
Far√≤ una modifica allo schema per aggiungere nuove colonne: credits_monthly_remaining, credits_extra_remaining, e site_unlock_at, utilizzando dbDelta per garantire che il tutto rimanga compatibile con la struttura esistente. Inoltre, aggiorner√≤ la gestione dei crediti, includendo funzioni di supporto dedicate alla gestione delle nuove colonne e a operazioni amministrative come il reset e l'aggiunta di crediti extra.

Integrando la pagina Licenze nell'admin dashboard
Decido di modificare la pagina "Licenze" esistente invece di crearne una nuova per velocizzare il processo. Aggiunger√≤ un sottomenu "Licenze Avanzate" che rimanda al nostro renderer, ma manterr√≤ la funzionalit√† esistente. Inoltre, implementer√≤ la visualizzazione di "Ultimo sblocco" e "Prossimo sblocco" nella tabella dei dettagli, con il relativo cooldown. Aggiungo un filtro per impostare i giorni di cooldown a 7.

Implementing site lock, credits, and admin features
import os, textwrap, re, zipfile, shutil, datetime, pathlib, math, json
base_dir=base
# helper for writing
def write(path, content):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path,'w',encoding='utf-8') as f:
        f.write(content)
# Add includes/class-db.php
db_php=textwrap.dedent("""\
<?php
/**
 * IPV Vendor DB Installer / Updater
 *
 * Adds missing columns and tables safely via dbDelta.
 *
 * @package IPV_Pro_Vendor
 * @version 1.4.1
 */
if ( ! defined( 'ABSPATH' ) ) exit;

class IPV_Vendor_DB {

    const DB_VERSION = '1.4.1';

    public static function install() : void {
        global $wpdb;

        require_once ABSPATH . 'wp
Creazione della pagina admin per le licenze
Sto aggiungendo i file per la pagina amministrativa delle licenze, utilizzando le nuove colonne dei crediti. Creer√≤ tabelle per le licenze e il ledger, con colonne come license_key, user, site_lock, e altri dettagli. Utilizzer√≤ una join con il table delle attivazioni per ottenere il sito attivo. Inoltre, implementer√≤ la funzionalit√† di ricerca e aggiorner√≤ la visualizzazione dei crediti.

ChatGPT sta ancora generando una risposta‚Ä¶